---
 lisp/gnus/gnus-sum.el  |   30 ++++++++++++++++++------------
 lisp/gnus/gnus-util.el |    6 +++---
 2 files changed, 21 insertions(+), 15 deletions(-)

--- a/lisp/gnus/gnus-sum.el
+++ b/lisp/gnus/gnus-sum.el
@@ -4819,8 +4819,7 @@
 	  ;; Even after binding max-lisp-eval-depth, the recursive
 	  ;; sorter might fail for very long threads.  In that case,
 	  ;; try using a (less well-tested) non-recursive sorter.
-	  (error (gnus-message 9 "Sorting threads with loop...")
-		 (gnus-sort-threads-loop
+	  (error (gnus-sort-threads-loop
 		  threads (gnus-make-sort-function
 			   gnus-thread-sort-functions))))
       (gnus-message 8 "Sorting threads...done"))))
@@ -4987,17 +4986,22 @@
   "Sort threads such that the thread with the most recently dated article comes first."
   (> (gnus-thread-latest-date h1) (gnus-thread-latest-date h2)))
 
-; Since this is called not only to sort the top-level threads, but
-; also in recursive sorts to order the articles within a thread, each
-; article will be processed many times.  Thus it speeds things up
-; quite a bit to use gnus-date-get-time, which caches the time value.
 (defun gnus-thread-latest-date (thread)
   "Return the highest article date in THREAD."
-  (apply 'max
-	 (mapcar (lambda (header) (gnus-float-time
-				   (gnus-date-get-time
-				    (mail-header-date header))))
-		 (message-flatten-list thread))))
+  (let ((previous-time 0))
+    (apply 'max
+	   (mapcar
+	    (lambda (header)
+	      (setq previous-time
+		    (condition-case ()
+			(gnus-float-time (mail-header-parse-date
+					  (mail-header-date header)))
+		      (error previous-time))))
+	    (sort
+	     (message-flatten-list thread)
+	     (lambda (h1 h2)
+	       (< (mail-header-number h1)
+		  (mail-header-number h2))))))))
 
 (defun gnus-thread-total-score-1 (root)
   ;; This function find the total score of the thread below ROOT.
@@ -8232,7 +8236,9 @@
 	  (when (and (vectorp (gnus-data-header d))
 		     (setq date (mail-header-date (gnus-data-header d))))
 	    (setq is-younger (time-less-p
-			      (time-since (gnus-date-get-time date))
+			      (time-since (condition-case ()
+					      (date-to-time date)
+					    (error '(0 0))))
 			      cutoff))
 	    (when (if younger-p
 		      is-younger
--- a/lisp/gnus/gnus-util.el
+++ b/lisp/gnus/gnus-util.el
@@ -455,10 +455,10 @@
 
 (defun gnus-user-date (messy-date)
   "Format the messy-date according to gnus-user-date-format-alist.
-Returns \"  ?  \" if there's bad input or if another error occurs.
+Returns \"  ?  \" if there's bad input or if an other error occurs.
 Input should look like this: \"Sun, 14 Oct 2001 13:34:39 +0200\"."
   (condition-case ()
-      (let* ((messy-date (gnus-float-time (gnus-date-get-time messy-date)))
+      (let* ((messy-date (gnus-float-time (safe-date-to-time messy-date)))
 	     (now (gnus-float-time))
 	     ;;If we don't find something suitable we'll use this one
 	     (my-format "%b %d '%y"))
@@ -477,7 +477,7 @@
 (defun gnus-dd-mmm (messy-date)
   "Return a string like DD-MMM from a big messy string."
   (condition-case ()
-      (format-time-string "%d-%b" (gnus-date-get-time messy-date))
+      (format-time-string "%d-%b" (safe-date-to-time messy-date))
     (error "  -   ")))
 
 (defmacro gnus-date-get-time (date)
