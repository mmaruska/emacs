@c -*-texinfo-*-
@c This is part of the GNU Emacs Lisp Reference Manual.
@c Copyright (C) 1990-1995, 1998-1999, 2001-2011
@c   Free Software Foundation, Inc.
@c See the file elisp.texi for copying conditions.
@setfilename ../../info/windows
@node Windows, Frames, Buffers, Top
@chapter Windows

This chapter describes the functions and variables related to Emacs
windows.  @xref{Frames}, for how windows are assigned an area of screen
available for Emacs to use.  @xref{Display}, for information on how text
is displayed in windows.

@menu
* Basic Windows::           Basic information on using windows.
* Windows and Frames::      Relating windows to the frame they appear on.
* Window Sizes::            Accessing a window's size.
* Resizing Windows::        Changing the sizes of windows.
* Splitting Windows::       Splitting one window into two windows.
* Deleting Windows::        Deleting a window gives its space to other windows.
* Selecting Windows::       The selected window is the one that you edit in.
* Cyclic Window Ordering::  Moving around the existing windows.
* Buffers and Windows::     Each window displays the contents of a buffer.
* Switching Buffers::       Higher-level functions for switching to a buffer.
* Choosing Window::         How to choose a window for displaying a buffer.
* Display Action Functions:: Subroutines for @code{display-buffer}.
* Choosing Window Options:: Extra options affecting how buffers are displayed.
* Window History::          Each window remembers the buffers displayed in it.
* Dedicated Windows::       How to avoid displaying another buffer in
                              a specific window.
* Quitting Windows::        How to restore the state prior to displaying a
                              buffer.
* Window Point::            Each window has its own location of point.
* Window Start and End::    Buffer positions indicating which text is
                              on-screen in a window.
* Textual Scrolling::       Moving text up and down through the window.
* Vertical Scrolling::      Moving the contents up and down on the window.
* Horizontal Scrolling::    Moving the contents sideways on the window.
* Coordinates and Windows:: Converting coordinates to windows.
* Window Configurations::   Saving and restoring the state of the screen.
* Window Parameters::       Associating additional information with windows.
* Window Hooks::            Hooks for scrolling, window size changes,
                              redisplay going past a certain point,
                              or window configuration changes.
@end menu


@node Basic Windows
@section Basic Concepts of Emacs Windows
@cindex window

A @dfn{window} in Emacs is the physical area of the screen in which a
buffer is displayed, see @ref{Buffers}.  The term is also used to refer
to a Lisp object that represents that screen area in Emacs Lisp.  It
should be clear from the context which is meant.

@cindex multiple windows
  Emacs groups windows into frames; see @ref{Frames}.  Each frame always
contains at least one window, but you can subdivide it into multiple,
non-overlapping Emacs windows.  Users create multiple windows so they
can look at several buffers at once.  Lisp libraries use multiple
windows for a variety of reasons, but most often to display related
information.  In Rmail, for example, you can move through a summary
buffer in one window while the other window shows messages one at a time
as they are reached.

@cindex terminal screen
@cindex screen of terminal
  The meaning of ``window'' in Emacs is similar to what it means in the
context of general-purpose window systems such as X, but not identical.
The X Window System places X windows on the screen; Emacs uses one or
more X windows as frames, and subdivides them into Emacs windows.  When
you use Emacs on a character-only terminal, Emacs treats the whole
terminal screen as one frame.

@cindex tiled windows
  Most window systems support arbitrarily located overlapping windows.
In contrast, Emacs windows are @dfn{tiled}; they never overlap, and
together they fill the whole screen or frame.  Because of the way in
which Emacs creates new windows (@pxref{Splitting Windows}) and resizes
them (@pxref{Resizing Windows}), not all conceivable tilings of windows
on an Emacs frame are actually possible.

  For practical purposes, a window exists only while it is displayed in
a frame.  Once removed from the frame, the window is effectively deleted
and should not be used, even though the Lisp object representing it
might be still referenced from other Lisp objects; see @ref{Deleting
Windows}.  Restoring a saved window configuration is the only way for a
window no longer on the screen to come back to life; see @ref{Window
Configurations}.

@defun windowp object
This function returns @code{t} if @var{object} is a window, @code{nil}
otherwise.  It can return @code{t} if @var{object} denotes a window that
has been deleted.
@end defun

@cindex live windows
@cindex internal windows
   For historical reasons a window is considered @dfn{live} if and only
if it currently displays a buffer; see @ref{Buffers and Windows}.  In
order to show multiple windows within one and the same frame, Emacs
organizes them in form of a tree called window tree; see @ref{Windows
and Frames}.  The internal nodes of a window tree are called internal
windows and are not considered live.  The leaf nodes of a window tree
constitute the windows displaying buffers and only they will be called
live here.

@defun window-live-p object
This function returns @code{t} if @var{object} is a live window and
@code{nil} otherwise.  A live window is a window that displays a buffer.
@end defun

@defun window-any-p object
This function returns @code{t} if @var{object} denotes a live or an
internal window and @code{nil} otherwise.  In particular, this function
returns @code{nil} if @var{object} is a window that has been
deleted.
@end defun

@cindex selected window
In each frame, at any time, one and only one window is designated as
@dfn{selected within the frame}.  Also, at any time, one frame is the
selected frame (@pxref{Input Focus}).  The window selected within the
selected frame is the @dfn{selected window}.

   The selected window is always a live window.  Its buffer is usually
the current buffer (except when @code{set-buffer} has been used); see
@ref{Current Buffer}.

@defun selected-window
This function returns the selected window.  This is the window in which
the cursor for selected windows (@pxref{Cursor Parameters}) appears and
to which many commands apply.
@end defun

The window handling functions can be roughly grouped into functions
operating on live windows only and functions that accept any window as
argument.  Many of these functions accept as argument the value
@code{nil} to specify the selected window.  The two functions below can
be used to ``normalize'' arguments specifying windows in a uniform
manner.

@defun window-normalize-any-window window
This function returns the normalized value for @var{window} which can be
any window that has not been deleted.  More precisely, if @var{window}
is @code{nil}, it returns the selected window.  If @var{window} denotes
a live or internal window, it returns that window.  Otherwise, this
function signals an error.
@end defun

@defun window-normalize-live-window window
This functions returns the normalized value for a live window
@var{window}.  More precisely, if @var{window} is @code{nil}, it returns
the selected window.  If @var{window} is a live window, it returns that
window.  Otherwise, this function signals an error.
@end defun


@node Windows and Frames
@section Windows and Frames

Each window is part of one and only one frame (@pxref{Frames}); you can
get that frame with the function described next.

@defun window-frame window
This function returns the frame that @var{window} is on.  The argument
@var{window} can be any window and defaults to the selected one.
@end defun

The following function returns a list of all live windows on a specific
frame.

@defun window-list &optional frame minibuf window
This function returns a list of @var{frame}'s live windows, starting
with @var{window}.  The optional argument @var{frame} has to denote a
live frame and defaults to the selected frame.  The optional argument
@var{window} has to denote a live window on the frame specified by
@var{frame} and defaults to the selected one.

The argument @var{minibuf} specifies if the minibuffer window shall be
included in the return value.  If @var{minibuf} is @code{t}, the result
always includes the minibuffer window.  If @var{minibuf} is @code{nil}
or omitted, that includes the minibuffer window only if it is active.
If @var{minibuf} is neither @code{nil} nor @code{t}, the result never
includes the minibuffer window.
@end defun

@cindex window tree
Windows within one and the same frame are organized in form of a tree
called @dfn{window tree}.  The leaf nodes of a window tree constitute
the windows visible to the user.  These are the windows associated with
buffers and are usually called live windows.  The internal nodes of a
window tree are needed for finding, traversing and displaying the live
windows.

   A minibuffer window (@pxref{Minibuffer Windows}) is not considered
part of its frame's window tree unless the frame is a minibuffer-only
frame.  Most functions covered in this section accept, however, the
minibuffer window as argument.  Also, the minibuffer window is listed by
the function @code{window-tree} described at the end of this section.

   A window tree is rooted at the root window of its frame.

@defun frame-root-window &optional frame-or-window
This function returns the root window of @var{frame-or-window}.  The
argument @var{frame-or-window} has to denote either a window or a frame
and defaults to the selected frame.  If @var{frame-or-window} denotes a
window, the return value is the root window of that window's frame.
This function always returns a window; a live window if the frame
specified by @var{frame-or-window} contains no other live windows and an
internal window otherwise.
@end defun

@cindex subwindow
All other windows of a frame with the exception of the minibuffer window
are subwindows of the frame's root window.  A window is considered a
@dfn{subwindow} of another window if it occupies a part of that other
window's screen area.

The functions described next allow to access the members of a window
tree and take an arbitrary window as argument.

@cindex parent window
@defun window-parent &optional window
Return @var{window}'s parent in the window tree.  The optional argument
@var{window} can denote an arbitrary window and defaults to the selected
one.  The return value is @code{nil} if @var{window} is a minibuffer
window or the root window of its frame and an internal window otherwise.
@end defun

@cindex child window
   Parent windows do not appear on the screen.  The screen area of a
parent window is the rectangular part of the window's frame occupied by
the window's @dfn{child windows}, that is, the set of windows having
that window as their parent.  Each parent window has at least two child
windows, so there are no ``Matryoshka'' windows.  Minibuffer windows do
not have child windows.

@cindex window combination
@cindex vertical combination
@cindex horizontal combination
The children of any parent window form either a vertical or a horizontal
combination of windows.  A @dfn{vertical combination} is a set of
windows arranged one above each other.  A @dfn{horizontal combination}
is a set of windows arranged side by side.  Consider the frame shown
below (for simplicity we assume that the frame does not contain a
minibuffer window):

@smallexample
@group
     ______________________________________
    | ______  ____________________________ |
    ||      || __________________________ ||
    ||      ||| ___________  ___________ |||
    ||      ||||           ||           ||||
    ||      ||||           ||           ||||
    ||      ||||_____W6____||_____W7____||||
    ||      |||____________W4____________|||
    ||      || __________________________ ||
    ||      |||                          |||
    ||      |||____________W5____________|||
    ||__W2__||_____________W3_____________ |
    |__________________W1__________________|

@end group
@end smallexample

The root window of the frame is @code{W1}---a horizontal combination of
the live window @code{W2} and the internal window @code{W3}.  Hence
@code{(window-parent W1)} is @code{nil} while @code{(window-parent W2)}
and @code{(window-parent W3)} are both @code{W1}.

   The internal window @code{W3} is a vertical combination of @code{W4}
and the live window @code{W5}.  The internal window @code{W4} is a
horizontal combination of the live windows @code{W6} and @code{W7}.  The
windows you can actually see on the screen are @code{W2}, @code{W5},
@code{W6} and @code{W7}.

   For any parent window, the first child window can be retrieved by the
functions given next.

@defun window-top-child &optional window
This function returns @var{window}'s first vertical child window.  The
optional argument @var{window} can be an arbitrary window and defaults
to the selected one.  The return value is @code{nil} if @var{window} is
a live window or its children form a horizontal combination.  In the
example above @code{(window-top-child W3)} is @code{W4} while
@code{(window-top-child W4)} is @code{nil}.
@end defun

@defun window-left-child &optional window
This function returns @var{window}'s first horizontal child window.  The
optional argument @var{window} can be an arbitrary window and defaults
to the selected one.  The return value is @code{nil} if @var{window} is
a live window or its children form a vertical combination.  In the
example above @code{(window-left-child W4)} is @code{W6} while
@code{(window-left-child W3)} is @code{nil}.
@end defun

@defun window-child window
This function return @var{window}'s first child window.  The return
value is @code{nil} if @var{window} is a live window.  In the example
above @code{(window-child W3)} is @code{W4} while @code{(window-child
W4)} is @code{W6}.
@end defun

The following function is useful to determine whether a window is part
of a vertical or horizontal combination.

@defun window-iso-combined-p &optional window horizontal
This function returns non-@code{nil} if and only if @var{window} is
vertically combined.  The argument @var{window} can specify any window
and defaults to the selected one.  The actual return value is the first
vertical child of window.

If the optional argument @var{horizontal} is non-@code{nil}, this means
to return non-@code{nil} if and only if @var{window} is horizontally
combined.  In this case, the return value is the first horizontal child
of window.
@end defun

@cindex sibling window
For any window that is part of a combination, the other windows in that
combination are called the window's @dfn{siblings}.  The only windows
that do not have siblings are root windows of frames and minibuffer
windows.  A window's siblings can be retrieved with the following two
functions.

@defun window-next-sibling &optional window
This function returns @var{window}'s next sibling.  The optional
argument @var{window} can be an arbitrary window and defaults to the
selected window.  It returns @code{nil} if @var{window} is the last
child of its parent.  In our example @code{(window-next-sibling W2)} is
@code{W3} while @code{(window-next-sibling W3)} is @code{nil}.
@end defun

@defun window-prev-sibling &optional window
This function returns @var{window}'s previous sibling.  The optional
argument @var{window} can be an arbitrary window and defaults to the
selected window.  It returns @code{nil} if @var{window} is the first
child of its parent. In our example @code{(window-prev-sibling W3)} is
@code{W2} and @code{(window-prev-sibling W2)} is @code{nil}.
@end defun

The functions @code{window-next-sibling} and @code{window-prev-sibling}
should not be confused with the functions @code{next-window} and
@code{previous-window} which respectively return the next and previous
window in the cyclic ordering of windows, see @ref{Cyclic Window
Ordering}.

   In order to find the first live window on a frame, the following
function can be used.

@defun frame-first-window &optional frame-or-window
This function returns the live window at the upper left corner of the
frame specified by @var{frame-or-window}.  The argument
@var{frame-or-window} must denote a window or a live frame and defaults
to the selected frame.  If @var{frame-or-window} specifies a window,
this function returns the first window on that window's frame.  Under
the assumption that the frame from our canonical example is selected
@code{(frame-first-window)} returns @code{W2}.
@end defun

You can get the window tree of a frame with the following function.

@cindex window tree
@defun window-tree &optional frame
This function returns the window tree for frame @var{frame}.  The
optional argument @var{frame} must be a live frame and defaults to the
selected one.

The return value is a list of the form @code{(@var{root} @var{mini})},
where @var{root} represents the window tree of the frame's
root window, and @var{mini} is the frame's minibuffer window.

If the root window is live, @var{root} specifies the root window and
nothing else.  Otherwise, @var{root} is a list @code{(@var{dir}
@var{edges} @var{w1} @var{w2} ...)} where @var{dir} is @code{nil} for a
horizontal combination, and @code{t} for a vertical combination,
@var{edges} gives the size and position of the combination, and the
remaining elements are the child windows.  Each child window may again
be a live window or a list representing a window combination, and so on.
The @var{edges} element is a list @code{(@var{left}@var{ top}@var{
right}@var{ bottom})} similar to the value returned by
@code{window-edges}, see @ref{Coordinates and Windows}.
@end defun


@node Window Sizes
@section Window Sizes
@cindex window size
@cindex size of window

Emacs windows are rectangular.  The structure of a live window can be
roughly sketched as follows:

@smallexample
@group
         _________________________________________ 
      ^ |______________ Header Line_______________| 
      | |LS|LF|LM|                       |RM|RF|RS| ^
      | |  |  |  |                       |  |  |  | |
 Window |  |  |  |       Text Area       |  |  |  | Window
 Total  |  |  |  |     (Window Body)     |  |  |  | Body
 Height |  |  |  |                       |  |  |  | Height
      | |  |  |  |<- Window Body Width ->|  |  |  | |
      | |__|__|__|_______________________|__|__|__| v
      v |_______________ Mode Line _______________|

         <----------- Window Total Width -------->

@end group
@end smallexample

@cindex window body
@cindex body of a window
The text area constitutes the body of the window.  In its most simple
form, a window consists of its body alone.  LS and RS stand for the left
and right scroll bar (@pxref{Scroll Bars}) respectively.  Only one of
them can be present at any time.  LF and RF denote the left and right
fringe, see @ref{Fringes}.  LM and RM, finally, stand for the left and
right display margin, see @ref{Display Margins}.  The header line, if
present, is located above theses areas, the mode line below, see
@ref{Mode Line Format}.

@cindex window height
@cindex total window height
@cindex height of a window
@cindex total height of a window
The @dfn{total height of a window} is specified as the total number of
lines occupied by the window.  Any mode or header line is included in a
window's total height.  For an internal window, the total height is
calculated recursively from the total heights of its child windows.

@cindex window width
@cindex total window width
@cindex width of a window
@cindex total width of a window
The @dfn{total width of a window} denotes the total number of columns of
the window.  Any scroll bar and the column of @samp{|} characters that
separate the window from its right sibling are included in a window's
total width.  On a window-system, fringes and display margins are
included in a window's total width too.  For an internal window, the
total width is calculated recursively from the total widths of its child
windows.

@cindex total size of a window
@cindex total window size
The following function is the standard interface for getting the total
size of any window:

@defun window-total-size &optional window &optional horizontal
This function returns the total number of lines of @var{window}.  The
argument @var{window} can denote any window and defaults to the selected
one.  If @var{window} is live, the return value includes any header or
mode lines of @var{window}.  If @var{window} is internal, the return
value is the sum of the total heights of @var{window}'s child windows
provided these are vertically combined and the height of @var{window}'s
first child if they are horizontally combined.

   If the optional argument @var{horizontal} is non-@code{nil}, this
function returns the total number of columns of @var{window}.  If
@var{window} is live, the return value includes any vertical divider
column or scroll bars of @var{window}.  On a window-system, the return
value includes the space occupied by any margins and fringes of
@var{window} too.  If @var{window} is internal, the return value is the
sum of the total widths of @var{window}'s child windows provided these
are horizontally combined and the width of @var{window}'s first child
otherwise.
@end defun

Alternatively, the following two functions can be used to retrieve
either the total height or the total width of a window:

@defun window-total-height &optional window
This function returns the total number of lines of @var{window}.
@var{window} can be any window and defaults to the selected one.  The
return value includes @var{window}'s mode line and header line, if any.
If @var{window} is internal the return value is the sum of heights of
@var{window}'s child windows for a vertical combination and the height
of @var{window}'s first child otherwise.
@end defun

@defun window-total-width &optional window
This function returns the total number of columns of @var{window}.
@var{window} can be any window and defaults to the selected one.  The
return value includes any vertical dividers or scrollbars of
@var{window}.  On a window-system the return value also includes the
space occupied by any margins and fringes of @var{window}.  If
@var{window} is internal, the return value is the sum of the widths of
@var{window}'s child windows for a horizontal combination and the width
of @var{window}'s first child otherwise.
@end defun

The total height of any window is usually less than the height of the
window's frame, because the latter may also include the minibuffer
window.  Depending on the toolkit in use, the frame height can also
include the menu bar and the tool bar (@pxref{Size and Position}).
Therefore, in general it is not straightforward to compare window and
frame heights.  The following function is useful to determine whether
there are no other windows above or below a specified window.

@cindex full-height window
@defun window-full-height-p &optional window
This function returns non-@code{nil} if there is no other window above
or below @var{window} on the containing frame.  More precisely, this
function returns @code{t} if and only if the total height of
@var{window} equals the total height of the root window (@pxref{Windows
and Frames}) of @var{window}'s frame.  The @var{window} argument may
denote any window and defaults to the selected one.
@end defun

@cindex full-width window
The following function can be used to determine whether there are no
other windows on the left or right of a specified window.

@defun window-full-width-p &optional window
This function returns non-@code{nil} if there are no other windows on
the left or right of @var{window}; @code{nil} otherwise.  More
precisely, this function returns @code{t} if and only if the total width
of @var{window} equals the total width of the root window
(@pxref{Windows and Frames}) of @var{window}'s frame.  The @var{window}
argument may denote any window and defaults to the selected one.
@end defun

@cindex top line of window
@cindex left column of window
  The windows of a frame are unambiguously characterized by the
combination of their top line and left column within that frame.

@defun window-top-line &optional window
This function returns the top line of @var{window}.  The argument
@var{window} can denote any window and defaults to the selected one.
@end defun

@defun window-left-column &optional window
This function returns the left column of @var{window}.  The argument
@var{window} can denote any window and defaults to the selected one.
@end defun

For a frame displaying one window only, that window's top line and left
column are both zero.  When a frame displays a window @var{WB} below a
window @var{WA}, the top line of @var{WB} can be calculated by adding
the total height of @var{WA} to the top line of @var{WA}.  When a frame
displays a window @var{WR} on the right of a window @var{WL}, the left
column of @var{WR} can be calculated by adding the total width of
@var{WL} to the left column of @var{WL}.

@cindex window body height
@cindex body height of a window
The @dfn{body height of a window} is specified as the total number of
lines occupied by the window's text area.  Mode or header lines are not
included in a window's body height.

@cindex window body width
@cindex body width of a window
The @dfn{body width of a window} denotes the total number of columns
occupied by the window's text area.  Scroll bars or columns of @samp{|}
characters that separate side-by-side windows are not included in a
window's body width.

@cindex body size of a window
@cindex window body size
The following functions retrieve height and width of the body of a live
window:

@defun window-body-size &optional window horizontal
This function returns the number of lines of @var{window}'s text area.
@var{window} must be a live window and defaults to the selected one.
The return value does not count any mode or header line of @var{window}.

Optional argument @var{horizontal} non-@code{nil} means to return the
number of columns of @var{window}'s text area.  In this case the return
value does not include any vertical divider or scroll bar owned by
@var{window}.  On a window-system the return value does not include the
number of columns used for @var{window}'s fringes or display margins
either.
@end defun

@defun window-body-height &optional window
This function returns the number of lines of @var{window}'s body.
@var{window} must be a live window and defaults to the selected one.

The return value does not include @var{window}'s mode line and header
line, if any.  If a line at the bottom of the window is only partially
visible, that line is included in the return value.  If you do not
want to include a partially visible bottom line in the return value,
use @code{window-text-height} instead.
@end defun

@defun window-body-width &optional window
This function returns the number of columns of @var{window}'s body.
@var{window} must be a live window and defaults to the selected one.

The return value does not include any vertical dividers or scroll bars
owned by @var{window}.  On a window-system the return value does not
include the number of columns used for @var{window}'s fringes or
display margins either.
@end defun

The following functions have been used in earlier versions of Emacs.
They are still supported but due to the confusing nomenclature they
should not be used any more in future code.

@defun window-height &optional window
This function is an alias for `window-total-height', see above.
@end defun

@defun window-width &optional window
This function is an alias for `window-body-width', see above.
@end defun

@cindex minimum window size
  The following two options constrain the sizes of windows to a minimum
height and width.  Their values are honored when windows are split
(@pxref{Splitting Windows}) or resized (@pxref{Resizing Windows}).  Any
request to make a window smaller than specified here will usually result
in an error.

@defopt window-min-height
The value of this variable specifies how short a window may be.  The
value is measured in line units and has to account for any header or
mode line.  The default value for this option is @code{4}.  Values less
than @code{1} are ignored.
@end defopt

@defopt window-min-width
The value of this variable specifies how narrow a window may be.  The
value is measured in characters and includes any margins, fringes,
scroll bar and vertical divider column.  The default value for this
option is @code{10}.  A value less than @code{2} is ignored.
@end defopt

Applications should not rebind these variables.  To shrink a specific
window to a height or width less than the one specified here, they
should rather invoke @code{window-resize} (@pxref{Resizing Windows})
with a non-@code{nil} @var{ignore} argument.  The function
@code{split-window} (@pxref{Splitting Windows}) can make a window
smaller than specified here by calling it with a non-@code{nil}
@var{size} argument.  Interactively, the values specified here cannot be
overridden.

   Earlier versions of Emacs could delete a window when its size dropped
below @code{window-min-height} or @code{window-min-width}.  As a rule,
the current version of Emacs does no more delete windows by side-effect.
The only exception to this rule are requests to resize a frame which may
implicitly delete windows when they do not fit on the frame any more,
see @ref{Size and Position}.

   The size of a window can be fixed which means that it cannot be split
(@pxref{Splitting Windows}) or resized (@pxref{Resizing Windows}).

@cindex fixed-size window
@defvar window-size-fixed
If this variable is non-@code{nil}, in a given buffer, then the size of
any window displaying that buffer remains fixed unless you either
explicitly change it or Emacs has no other choice.

If the value is @code{height}, then only the window's height is fixed;
if the value is @code{width}, then only the window's width is fixed.
Any other non-@code{nil} value fixes both the width and the height.

This variable automatically becomes buffer-local when set.
@end defvar

Commands supposed to explicitly change the size of windows such as
@code{enlarge-window} (@pxref{Resizing Windows}) get an error if they
had to change a window size which is fixed.  Other functions like
@code{window-resize} (@pxref{Resizing Windows}) have an optional
@var{ignore} argument which allows to change the size of fixed-size
windows.

   Deleting a window or changing a frame's size may change the size of a
fixed-size window, if there is no other alternative.

   The height of a vertical combination of windows cannot be changed
when the height of all these windows is fixed.  Its width cannot be
changed if the width of at least one of these windows is fixed.
Similarly, the width of a horizontal combination of windows cannot be
changed when the width of all these windows is fixed.  Its height cannot
be changed if the height of at least one of these windows is fixed.

   The next function allows to check whether the size of an arbitrary           
window is fixed.

@defun window-size-fixed-p &optional window horizontal
This function returns non-@code{nil} if @var{window}'s height is fixed.
The argument @var{window} can be an arbitrary window and defaults to the
selected one.  Optional argument @var{horizontal} non-@code{nil} means
return non-@code{nil} if @var{window}'s width is fixed.

If this function returns @code{nil}, this does not necessarily mean that
@var{window} can be resized in the desired direction.  The function
@code{window-resizable} (@pxref{Resizing Windows}) can tell that.
@end defun


@node Resizing Windows
@section Resizing Windows
@cindex window resizing
@cindex resize window
@cindex changing window size
@cindex window size, changing

Emacs does not permit overlapping windows or gaps between windows, so
changing the size of a window always affects at least one other window.
When a frame contains just one window, that window can be resized only
by resizing the window's frame.  The functions described below are
therefore meaningful only in the context of a frame containing at least
two windows.  The size of the corresponding frame never changes when
invoking a function described in this section.

   The routines changing window sizes always operate in one dimension at
a time.  This means that windows can be resized only either vertically
or horizontally.  If a window shall be resized in both dimensions, it
must be resized in one dimension first and in the other dimension
afterwards.  If the second resize operation fails, the frame might end
up in an unsatisfactory state.  To avoid such states, it might be useful
to save the current window configuration (@pxref{Window Configurations})
before attempting the first resize operation and restore the saved
configuration in case the second resize operation fails.

   Functions that resize windows are supposed to obey restrictions
imposed by window minimum sizes and fixed-size windows, see @ref{Window
Sizes}.  In order to determine whether resizing a specific window is
possible in the first place, the following function can be used:

@defun window-resizable window delta &optional horizontal ignore side noup nodown
This function returns @var{delta} if the size of @var{window} can be
changed vertically by @var{delta} lines.  Optional argument
@var{horizontal} non-@code{nil} means to return @var{delta} if
@var{window} can be resized horizontally by @var{delta} columns.  A
return value of zero means that @var{window} is not resizable.

If @var{delta} is a positive number, this means that @var{window} shall
be enlarged by @var{delta} lines or columns.  If @var{window} cannot be
enlarged by @var{delta} lines or columns, this function returns the
maximum value in the range from 0 to @var{delta} by which @var{window}
can be enlarged.

If @var{delta} is a negative number, this means that @var{window} shall
be shrunk by -@var{delta} lines or columns.  If @var{window} cannot be
shrunk by -@var{delta} lines or columns, this function returns the
minimum value in the range from @var{delta} to 0 that can be used for
shrinking @var{window}.

Optional argument @var{ignore} non-@code{nil} means ignore any
restrictions imposed by the variables @code{window-min-height} or
@code{window-min-width} and @code{window-size-fixed}.  In this case the
minimum height of a window is specified as the minimum number of lines
that allow viewing any header or mode line and at least one line of the
text area of window.  The minimum width of a window includes any
fringes, margins and the scroll bar as well as two text columns.

If @var{ignore} denotes a window, this means to ignore restrictions for
that window only.  If @var{ignore} equals the constant @code{safe}, this
means a live window may get as small as one line or two columns.

Optional argument @var{noup} non-@code{nil} means don't go up in the
window tree but try to steal or distribute the space needed for the
resize operation among the other windows within @var{window}'s
combination.  Optional argument @var{nodown} non-@code{nil} means don't
check whether @var{window} itself and its subwindows can be resized.
@end defun

The function @code{window-resizable} does not change any window sizes.
The following function does:

@defun window-resize window delta &optional horizontal ignore
This function resizes @var{window} vertically by @var{delta} lines.  The
argument @var{window} can denote an arbitrary window and defaults to the
selected one.  An attempt to resize the root window of a frame will
raise an error.

Second argument @var{delta} a positive number means @var{window} shall
be enlarged by @var{delta} lines.  If @var{delta} is negative, that
means @var{window} shall be shrunk by -@var{delta} lines.

Optional argument @var{horizontal} non-@code{nil} means to resize
@var{window} horizontally by @var{delta} columns.  In this case a
positive @var{delta} means enlarge @var{window} by @var{delta} columns.
A negative @var{delta} means @var{window} shall be shrunk by
-@var{delta} columns.

Optional argument @var{ignore} has the same meaning as for the function
@code{window-resizable} above.

This function can simultaneously move two edges of WINDOW.  Exactly
which edges of @var{window} are moved and which other windows are
resized along with @var{window} is determined by the splits and nest
status of the involved windows (@pxref{Splitting Windows}).  If only the
low (right) edge of @var{window} shall be moved, the function
@code{adjust-window-trailing-edge} described below should be used.
@end defun

The next four commands are simple interfaces to @code{window-resize}.
They always operate on the selected window, never delete any window, and
always raise an error when resizing would violate a restriction imposed
by @code{window-min-height}, @code{window-min-width}, or
@code{window-size-fixed}.

@deffn Command enlarge-window delta &optional horizontal
This function makes the selected window @var{delta} lines taller.
Interactively, if no argument is given, it makes the selected window one
line taller.  If optional argument @var{horizontal} is non-@code{nil},
it makes the selected window wider by @var{delta} columns.  If
@var{delta} is negative, it shrinks the selected window by -@var{delta}
lines or columns.  The return value is @code{nil}.
@end deffn

@deffn Command enlarge-window-horizontally delta
This function makes the selected window @var{delta} columns wider.
Interactively, if no argument is given, it makes the selected window one
column wider.
@end deffn

@deffn Command shrink-window delta &optional horizontal
This function makes the selected window @var{delta} lines smaller.
Interactively, if no argument is given, it makes the selected window one
line smaller.  If optional argument @var{horizontal} is non-@code{nil},
it makes the selected window narrower by @var{delta} columns.  If
@var{delta} is negative, it enlarges the selected window by -@var{delta}
lines or columns.  The return value is @code{nil}.
@end deffn

@deffn Command shrink-window-horizontally delta
This function makes the selected window @var{delta} columns narrower.
Interactively, if no argument is given, it makes the selected window one
column narrower.
@end deffn

The following function is useful for moving the line dividing two
windows.

@defun adjust-window-trailing-edge window delta &optional horizontal
This function moves @var{window}'s bottom edge by @var{delta} lines.
Optional argument @var{horizontal} non-@code{nil} means to move
@var{window}'s right edge by @var{delta} columns.  The argument
@var{window} defaults to the selected window.

If @var{delta} is greater zero, this moves the edge downwards or to the
right.  If @var{delta} is less than zero, this moves the edge upwards or
to the left. If the edge can't be moved by @var{delta} lines or columns,
it is moved as far as possible in the desired direction but no error is
signalled.

This function tries to resize windows adjacent to the edge that is
moved.  Only if this is insufficient, it will also resize windows not
adjacent to that edge.  As a consequence, if you move an edge in one
direction and back in the other direction by the same amount, the
resulting window configuration will not be necessarily identical to the
one before the first move.  So if your intend to just resize
@var{window}, you should not use this function but call
@code{window-resize} (see above) instead.
@end defun

@deffn Command fit-window-to-buffer &optional window max-height min-height override
This command makes @var{window} the right height to display its
contents exactly.  The default for @var{window} is the selected window.

The optional argument @var{max-height} specifies the maximum total
height the window is allowed to be; @code{nil} means use the maximum
permissible height of a window on @var{window}'s frame.  The optional
argument @var{min-height} specifies the minimum toatl height for the
window; @code{nil} means use @code{window-min-height}.  All these height
values include the mode line and/or header line.

If the optional argument @var{override} is non-@code{nil}, this means to
ignore any restrictions imposed by @code{window-min-height} and
@code{window-min-width} on the size of @var{window}.

This function returns non-@code{nil} if it orderly resized @var{window},
and @code{nil} otherwise.
@end deffn

@deffn Command shrink-window-if-larger-than-buffer &optional window
This command shrinks @var{window} vertically to be as small as possible
while still showing the full contents of its buffer---but not less than
@code{window-min-height} lines.  The argument @var{window} must denote
a live window and defaults to the selected one.

However, this command does nothing if the window is already too small to
display the whole text of the buffer, or if part of the contents are
currently scrolled off screen, or if the window is not the full width of
its frame, or if the window is the only window in its frame.

This command returns non-@code{nil} if it actually shrank the window
and @code{nil} otherwise.
@end deffn

@cindex balancing window sizes
Emacs provides two functions to balance windows, that is, to even out
the sizes of all windows on the same frame.  The minibuffer window and
fixed-size windows are not resized by these functions.

@deffn Command balance-windows &optional window-or-frame
This function balances windows in a way that gives more space to
full-width and/or full-height windows.  If @var{window-or-frame}
specifies a frame, it balances all windows on that frame.  If
@var{window-or-frame} specifies a window, it balances that window and
its siblings (@pxref{Windows and Frames}) only.
@end deffn

@deffn Command balance-windows-area
This function attempts to give all windows on the selected frame
approximately the same share of the screen area.  This means that
full-width or full-height windows are not given more space than other
windows.
@end deffn

@cindex maximizing windows
The following function can be used to give a window the maximum possible
size without deleting other ones.

@deffn Command maximize-window &optional window
This function maximizes @var{window}.  More precisely, this makes
@var{window} as large as possible without resizing its frame or deleting
other windows.  @var{window} can be any window and defaults to the
selected one.
@end deffn

@cindex minimizing windows
To make a window as small as possible without deleting it the
following function can be used.

@deffn Command minimize-window &optional window
This function minimizes @var{window}.  More precisely, this makes
@var{window} as small as possible without deleting it or resizing its
frame.  @var{window} can be any window and defaults to the selected one.
@end deffn


@node Splitting Windows
@section Splitting Windows
@cindex splitting windows
@cindex window splitting

The functions described below are the primitives needed for creating a
new window.  They do not accept a buffer as an argument.  Rather, they
``split'' an existing window into two halves, both displaying the buffer
previously visible in the window that was split.

@deffn Command split-window &optional window size side
This function creates a new window adjacent to @var{window}.  It returns
the new window which is always a live window.  The argument @var{window}
can denote any window and defaults to the selected one.  This function
does not change the selected window.

Optional second argument @var{size} a positive number means make
@var{window} @var{size} lines (or columns) tall.  If @var{size} is
negative, make the new window @minus{}@var{size} lines (or columns)
tall.  If @var{size} is omitted or @code{nil}, then @var{window} is
divided evenly into two parts.  (If there is an odd line, it is
allocated to the new window.)

If splitting would result in making a window smaller than
@code{window-min-height} or @code{window-min-width} (@pxref{Window
Sizes}), this function usually signals an error.  However, if @var{size}
is non-@code{nil} and valid, a new window of the requested size is
created.  (A size value would be invalid if it assigned less than one
line or less than two columns to the new window.)

Optional third argument @var{side} @code{nil} (or @code{below})
specifies that the new window shall be located below @var{window}.  The
value @code{above} means the new window will be located above
@var{window}.  In both cases @var{size} specifies the new number of
lines for @var{window} (or the new window if @var{size} is negative)
including space reserved for the mode and/or header line.

If @var{side} is @code{t} or @code{right} the new window will be
positioned on the right side of @var{window}.  The value @code{left}
means the new window will be located on the left side of @var{window}.
In both cases @var{size} specifies the new number of columns for
@var{window} (or the new window provided @var{size} is negative)
including space reserved for margins, fringes and the scroll bar or a
divider column.

Any other non-@code{nil} value for @var{side} is currently handled like
@code{t} (or @code{right}).  Since this might change in the future,
application programs should refrain from using other values.

If @var{window} is live, properties of the new window like margins and
scroll bars are inherited from @var{window}.  If @var{window} is an
internal window, these properties, as well as the buffer shown in the
new window, are inherited from the window selected on @var{window}'s
frame.

If @code{ignore-window-parameters} is non-@code{nil}, this function
ignores window parameters (@pxref{Window Parameters}).  Otherwise, if
the @code{split-window} parameter of @var{window} is @code{t}, it splits
the window disregarding any other window parameters.  If the
@code{split-window} parameter specifies a function, that function is
called with the arguments @var{window}, @var{size}, and @var{side} to
split @var{window}.  If that function is @code{ignore}, nothing is done.
@end deffn

The following example starts with one window on a screen that is 50
lines high by 80 columns wide; then it splits the window.

@smallexample
@group
(setq W1 (selected-window))
     @result{} #<window 8 on windows.texi>
(setq W2 (split-window W1 15))
     @result{} #<window 28 on windows.texi>
@end group
@group
(window-top-line W1)
     @result{} 0
(window-total-size W1)
     @result{} 15
(window-top-line W2)
     @result{} 15
@end group
@end smallexample

The screen looks like this:

@smallexample
@group
         __________
        |          |  line 0
        |    W1    |
        |__________|
        |          |  line 15
        |    W2    |
        |__________|
                      line 50
 column 0   column 80
@end group
@end smallexample

Next, split the top window into two side-by-side windows:

@smallexample
@group
(setq W3 (split-window W1 35 t))
     @result{} #<window 32 on windows.texi>
@end group
@group
(window-left-column W1)
     @result{} 0
(window-total-size W1 t)
     @result{} 35
(window-left-column W3)
     @result{} 35
@end group
@end smallexample

@need 3000
Now the screen looks like this:

@smallexample
@group
     column 35
         __________
        |    |     |  line 0
        | W1 |  W3 |
        |____|_____|
        |          |  line 15
        |    W2    |
        |__________|
                      line 50
 column 0   column 80
@end group
@end smallexample

Normally, Emacs indicates the border between two side-by-side windows
with a scroll bar (@pxref{Scroll Bars}), or with @samp{|} characters.  The
display table can specify alternative border characters; see @ref{Display
Tables}.

Below we describe how @code{split-window} can be used to create the
window configuration from our earlier example (@pxref{Windows and
Frames}) and how internal windows are created for this purpose.  We
start with a frame containing one live window @code{W2} (in the
following scenarios window names are assigned in an arbitrary manner in
order to match the names of the example).  Evaluating the form
@code{(split-window W2 8 t)} creates a new internal window @code{W1}
with two children---@code{W2} (the window we've split) and a new leaf
window @code{W6}:
@smallexample
@group
     ______________________________________
    | ______  ____________________________ |
    ||      ||                            ||
    ||      ||                            ||
    ||      ||                            ||
    ||      ||                            ||
    ||      ||                            ||
    ||      ||                            ||
    ||      ||                            ||
    ||      ||                            ||
    ||      ||                            ||
    ||      ||                            ||
    ||__W2__||_____________W6_____________ |
    |__________________W1__________________|

@end group
@end smallexample

Evaluating now @code{(split-window W6 -3)} creates another internal
window @code{W3} with two children---@code{W6} and a new live window
@code{W5}.  This leaves us with a vertically combined window @code{W3}
embedded in the horizontally combined window @code{W1}:
@smallexample
@group
     ______________________________________
    | ______  ____________________________ |
    ||      || __________________________ ||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||                          |||
    ||      |||____________W6____________|||
    ||      || __________________________ ||
    ||      |||                          |||
    ||      |||____________W5____________|||
    ||__W2__||_____________W3_____________ |
    |__________________W1__________________|

@end group
@end smallexample

Finally, evaluating @code{(split-window W6 nil t)} should get us the
desired configuration as depicted below.
@smallexample
@group
     ______________________________________
    | ______  ____________________________ |
    ||      || __________________________ ||
    ||      ||| ___________  ___________ |||
    ||      ||||           ||           ||||
    ||      ||||           ||           ||||
    ||      ||||_____W6____||_____W7____||||
    ||      |||____________W4____________|||
    ||      || __________________________ ||
    ||      |||                          |||
    ||      |||____________W5____________|||
    ||__W2__||_____________W3_____________ |
    |__________________W1__________________|

@end group
@end smallexample

The scenario sketched above is the standard way to obtain the desired
configuration.  In Emacs 23 it was also the only way to do that since
Emacs 23 did't allow splitting internal windows.

With Emacs 24 you can also proceed as follows: Split an initial window
@code{W6} by evaluating @code{(split-window W6 -3)} to produce the
following vertical combination:
@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W6_________________||
    | ____________________________________ |
    ||                                    ||
    ||_________________W5_________________||
    |__________________W3__________________|

@end group
@end smallexample

Evaluating now @code{(split-window (window-parent W6) -8 'left)} or,
equivalently, @code{(split-window W3 -8 'left)} should now produce the
penultimate configuration from the previous scenario from where we can
continue as described before.

   Another strategy starts with splitting an initial window @code{W6} by
evaluating @code{(split-window W6 nil nil t)} with the following result:
@smallexample
@group
     ______________________________________
    | _________________  _________________ |
    ||                 ||                 ||
    ||                 ||                 ||
    ||                 ||                 ||
    ||                 ||                 ||
    ||                 ||                 ||
    ||                 ||                 ||
    ||                 ||                 ||
    ||                 ||                 ||
    ||                 ||                 ||
    ||                 ||                 ||
    ||________W6_______||________W7_______||
    |__________________W4__________________|

@end group
@end smallexample

Evaluating now @code{(split-window W4 -3)} or @code{(split-window
(window-parent W6) -3)} should get us a configuration as shown next.
@smallexample
@group
     ______________________________________
    | ____________________________________ |
    || ________________  ________________ ||
    |||                ||                |||
    |||                ||                |||
    |||                ||                |||
    |||                ||                |||
    |||                ||                |||
    |||_______W6_______||________W7______|||
    ||_________________W4_________________||
    | ____________________________________ |
    ||                                    ||
    ||_________________W5_________________||
    |__________________W3__________________|

@end group
@end smallexample

The desired configuration can be now obtained by evaluating
@code{(split-window W3 -8 'left)} or, equivalently, @code{(split-window
(window-parent W5) -8 'left)}.

   For a final approach let's start with the configuration of two live
windows @code{W6} and @code{W7} shown above.  If we now evaluate
@code{(split-window W4 -8 'left)} or @code{(split-window (window-parent
W6) -8 'left)} we get the following configuration.
@smallexample
@group
     ______________________________________
    | ______  ____________________________ |
    ||      || ____________  ____________ ||
    ||      |||            ||            |||
    ||      |||            ||            |||
    ||      |||            ||            |||
    ||      |||            ||            |||
    ||      |||            ||            |||
    ||      |||            ||            |||
    ||      |||            ||            |||
    ||      |||______W6____||______W7____|||
    ||__W2__||_____________W4_____________||
    |__________________W1__________________|

@end group
@end smallexample

Evaluating now @code{(split-window W4 -3)} or, for example,
@code{(split-window (window-parent W6) -3)} should produce the desired
configuration.

  The two options described next can be used to tune the operation of
@code{split-window}.

@defopt window-splits
If this variable is nil, the function @code{split-window} can split a
window if and only if that window's screen estate is sufficiently large
to accommodate both--itself and the new window.

If this variable is non-@code{nil}, @code{split-window} tries to resize
all windows that are part of the same combination as the old window to
accommodate the new window.  Hence, the new window can be also created if
the old window is of fixed size or too small to split (@pxref{Window
Sizes}).

In any case, the value of this variable is assigned to the splits status
of the new window and, provided old and new window form a new
combination, of the old window as well.  The splits status of a window
can be retrieved by invoking the function @code{window-splits} and
altered by the function @code{set-window-splits} described next.

If @code{window-nest} (see below) is non-@code{nil}, the space for the
new window is exclusively taken from the old window, but the splits
status of the involved windows is nevertheless set as described here.
@end defopt

@defun window-splits &optional window
This function returns the splits status of @var{window}.  The argument
@var{window} can be any window and defaults to the selected one.

@cindex splits status
The @dfn{splits status} of a window specifies how resizing and deleting
that window may affect the size of other windows in the same window
combination.  More precisely, if @var{window}'s splits status is
@code{nil} and @var{window} is resized, the corresponding space is
preferably taken from (or given to) @var{window}'s right sibling.  When
@var{window} is deleted, its space is given to its left sibling.  If
@var{window}'s splits status is non-@code{nil}, resizing and deleting
@var{window} may resize @emph{all} windows in @var{window}'s
combination.

The splits status is initially set by @code{split-window}
from the current value of the variable @code{window-splits} (see above)
and can be reset by the function @code{set-window-splits} (see below).
@end defun

@defun set-window-splits window &optional status
This function sets the splits status (see above) of @var{window} to
@var{status}.  The argument @var{window} can be any window and defaults
to the selected one.  The return value is @var{status}.
@end defun

To illustrate the use of @code{window-splits} consider the following
window configuration:
@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W3_________________||
    |__________________W1__________________|

@end group
@end smallexample

Splitting window @code{W3} with @code{window-splits} @code{nil}
produces a configuration where the size of @code{W2} remains unchanged:
@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||                                    ||
    ||_________________W3_________________||
    | ____________________________________ |
    ||                                    ||
    ||_________________W4_________________||
    |__________________W1__________________|

@end group
@end smallexample

Splitting @code{W3} with @code{window-splits} non-@code{nil} instead
produces a configuration where all windows have approximately the same
height:

@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W3_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W4_________________||
    |__________________W1__________________|

@end group
@end smallexample

@defopt window-nest
If this variable is @code{nil}, @code{split-window} creates a new parent
window if and only if the old window has no parent window or shall be
split orthogonally to the combination it is part of.  If this variable
is non-@code{nil}, @code{split-window} always creates a new parent
window.  If this variable is always non-@code{nil}, a frame's window
tree is a binary tree so every window but the frame's root window has
exactly one sibling.

The value of this variable is also assigned to the nest status of the
new parent window.  The nest status of any window can be retrieved via
the function @code{window-nest} and altered by the function
@code{set-window-nest}, see below.
@end defopt

@defun window-nest &optional window
This function returns the nest status of @var{window}.  The argument
@var{window} can be any window and defaults to the selected one.  Note,
however, that the nest status is currently meaningful for internal
windows only.

@cindex nest status
The @dfn{nest status} of a window specifies whether that window may be
removed and its subwindows recombined with that window's siblings when
such a sibling's subwindow is deleted.  The nest status is initially
assigned by @code{split-window} from the current value of the variable
@code{window-nest} (see above) and can be reset by the function
@code{set-window-nest} (see below).

If the return value is @code{nil}, subwindows of @var{window} may be
recombined with @var{window}'s siblings when a window gets deleted.  A
return value of @code{nil} means that subwindows of @var{window} are
never (re-)combined with @var{window}'s siblings in such a case.
@end defun

@defun set-window-nest window &optional status
This functions sets the nest status (see above) of @var{window} to
@var{status}.  The argument @var{window} can be any window and defaults
to the selected one.  Note that setting the nest status is meaningful
for internal windows only.  The return value is @var{status}.
@end defun

To illustrate the use of @code{window-nest} consider the following
configuration (throughout the following examples we shall assume that
@code{window-splits} invariantly is @code{nil}).
@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W3_________________||
    |__________________W1__________________|

@end group
@end smallexample

Splitting @code{W2} into two windows above each other with
@code{window-nest} equal @code{nil} will get you a configuration like:
@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W4_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W3_________________||
    |__________________W1__________________|

@end group
@end smallexample

If you now enlarge window @code{W4}, Emacs steals the necessary space
from window @code{W3} resulting in a configuration like:
@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W4_________________||
    | ____________________________________ |
    ||                                    ||
    ||_________________W3_________________||
    |__________________W1__________________|

@end group
@end smallexample

Deleting window @code{W4}, will return its space to @code{W2} as
follows:
@smallexample
@group
     ______________________________________
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||                                    ||
    ||_________________W2_________________||
    | ____________________________________ |
    ||                                    ||
    ||_________________W3_________________||
    |__________________W1__________________|

@end group
@end smallexample

Hence, with respect to the initial configuration, window @code{W2} has
grown at the expense of window @code{W3}.  If, however, in the initial
configuration you had split @code{W2} with @code{window-nest} bound to
@code{t}, a new internal window @code{W5} would have been created as
depicted below.
@smallexample
@group
     ______________________________________
    | ____________________________________ |
    || __________________________________ ||
    |||                                  |||
    |||________________W2________________|||
    || __________________________________ ||
    |||                                  |||
    |||________________W4________________|||
    ||_________________W5_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W3_________________||
    |__________________W1__________________|

@end group
@end smallexample

Enlarging @code{W4} would now have stolen the necessary space from
@code{W2} instead of @code{W3} as
@smallexample
@group
     ______________________________________
    | ____________________________________ |
    || __________________________________ ||
    |||________________W2________________|||
    || __________________________________ ||
    |||                                  |||
    |||                                  |||
    |||________________W4________________|||
    ||_________________W5_________________||
    | ____________________________________ |
    ||                                    ||
    ||                                    ||
    ||_________________W3_________________||
    |__________________W1__________________|

@end group
@end smallexample

and the subsequent deletion of @code{W4} would have restored the initial
configuration.

For interactive use, Emacs provides two commands which always split the
selected window.

@deffn Command split-window-above-each-other &optional size
This function splits the selected window into two windows, one above the
other, leaving the upper of the two windows selected, with @var{size}
lines.  (If @var{size} is negative, then the lower of the two windows
gets @minus{}@var{size} lines and the upper window gets the rest, but
the upper window is still the one selected.)  However, if
@code{split-window-keep-point} (see below) is @code{nil}, then either
window can be selected.

   In other respects, this function is similar to @code{split-window}.
In particular, the upper window is the original one and the return value
is the new, lower window.
@end deffn

@defopt split-window-keep-point
If this variable is non-@code{nil} (the default), then
@code{split-window-above-each-other} behaves as described above.

   If it is @code{nil}, then @code{split-window-above-each-other}
adjusts point in each of the two windows to avoid scrolling.  (This is
useful on slow terminals.)  It selects whichever window contains the
screen line that point was previously on.  Other functions are not
affected by this variable.
@end defopt

@deffn Command split-window-side-by-side &optional size
This function splits the selected window into two windows
side-by-side, leaving the selected window on the left with @var{size}
columns.  If @var{size} is negative, the rightmost window gets
@minus{}@var{size} columns, but the leftmost window still remains
selected.
@end deffn


@node Deleting Windows
@section Deleting Windows
@cindex deleting windows

A window remains visible on its frame unless you @dfn{delete} it by
calling certain functions that delete windows.  A deleted window cannot
appear on the screen, but continues to exist as a Lisp object until
there are no references to it.  There is no way to cancel the deletion
of a window aside from restoring a saved window configuration
(@pxref{Window Configurations}).  Restoring a window configuration also
deletes any windows that aren't part of that configuration.  Erroneous
information may result from using a deleted window as if it were live.

@deffn Command delete-window &optional window
This function removes @var{window} from display and returns @code{nil}.
The argument @var{window} can denote any window and defaults to the
selected one.  An error is signaled if @var{window} is the only window
on its frame.  Hence @var{window} must have at least one sibling window
(@pxref{Windows and Frames}) in order to get deleted.

If the variable @code{ignore-window-parameters} (@pxref{Window
Parameters}) is non-@code{nil}, this function ignores all parameters of
@var{window}.  Otherwise, if the @code{delete-window} parameter of
@var{window} is @code{t}, it deletes the window disregarding other
window parameters.  If the @code{delete-window} parameter specifies a
function, that function is called with @var{window} as its sole
argument.

If the splits status of @var{window} (@pxref{Splitting Windows}) is
@code{nil}, the space @var{window} took up is given to its left sibling
if such a window exists and to its right sibling otherwise.  If the
splits status of @var{window} is non-@code{nil}, its space is
proportionally distributed among the remaining windows in the same
combination.
@end deffn

@deffn Command delete-other-windows &optional window
This function makes @var{window} fill its frame and returns @code{nil}.
The argument @var{window} can denote an arbitrary window and defaults to
the selected one.

If the variable @code{ignore-window-parameters} (@pxref{Window
Parameters}) is non-@code{nil}, this function ignores all parameters of
@var{window}.  Otherwise, if the @code{delete-other-windows} parameter
of @var{window} equals @code{t}, it deletes all other windows
disregarding any remaining window parameters.  If the
@code{delete-other-windows} parameter of @var{window} specifies a
function, it calls that function with @var{window} as its sole argument.
@end deffn

@deffn Command delete-windows-on &optional buffer-or-name frame
This function deletes all windows showing @var{buffer-or-name} and
returns nil.  If there are no windows showing @var{buffer-or-name}, it
does nothing.  The optional argument @var{buffer-or-name} may be a
buffer or the name of an existing buffer and defaults to the current
buffer.  Invoking this command on a minibuffer signals an error.

The function @code{delete-windows-on} operates by calling
@code{delete-window} for each window showing @var{buffer-or-name}.  If a
frame has several windows showing different buffers, then those showing
@var{buffer-or-name} are removed, and the other windows expand to fill
the space.

If all windows in some frame are showing @var{buffer-or-name} (including
the case where there is only one window), then that frame is deleted
provided there are other frames left.

The optional argument @var{frame} specifies which frames to operate on.
This function does not use it in quite the same way as the other
functions which scan all live windows (@pxref{Cyclic Window Ordering});
specifically, the values @code{t} and @code{nil} have the opposite of
their meanings in the other functions.  Here are the full details:

@itemize @bullet
@item @code{nil}
means operate on all frames.
@item @code{t}
means operate on the selected frame.
@item @code{visible}
means operate on all visible frames.
@item @code{0}
means operate on all visible or iconified frames.
@item A frame
means operate on that frame.
@end itemize
@end deffn


@node Selecting Windows
@section Selecting Windows
@cindex selecting a window

@defun select-window window &optional norecord
This function makes @var{window} the selected window, see @ref{Basic
Windows}.  Unless @var{window} already is the selected window, this also
makes @var{window}'s buffer (@pxref{Buffers and Windows}) the current
buffer.  Moreover, the cursor for selected windows will be displayed in
@var{window} after the next redisplay.  This function returns
@var{window}.

Normally, @var{window}'s selected buffer is moved to the front of the
buffer list (@pxref{The Buffer List}) and @var{window} becomes the most
recently selected window.  But if the optional argument @var{norecord}
is non-@code{nil}, the buffer list remains unchanged and @var{window}
does not become the most recently selected one.
@end defun

@cindex most recently selected windows
The sequence of calls to @code{select-window} with a non-@code{nil}
@var{norecord} argument determines an ordering of windows by their
selection time.  The function @code{get-lru-window} can be used to
retrieve the least recently selected live window in this ordering, see
@ref{Cyclic Window Ordering}.

@defmac save-selected-window forms@dots{}
This macro records the selected frame, as well as the selected window
of each frame, executes @var{forms} in sequence, then restores the
earlier selected frame and windows.  It also saves and restores the
current buffer.  It returns the value of the last form in @var{forms}.

This macro does not save or restore anything about the sizes,
arrangement or contents of windows; therefore, if @var{forms} change
them, the change persists.  If the previously selected window of some
frame is no longer live at the time of exit from @var{forms}, that
frame's selected window is left alone.  If the previously selected
window is no longer live, then whatever window is selected at the end of
@var{forms} remains selected.  The current buffer is restored if and
only if it is still live when exiting @var{forms}.

This macro changes neither the ordering of recently selected windows nor
the buffer list.
@end defmac

@defmac with-selected-window window forms@dots{}
This macro selects @var{window}, executes @var{forms} in sequence, then
restores the previously selected window and current buffer.  The ordering
of recently selected windows and the buffer list remain unchanged unless
you deliberately change them within @var{forms}, for example, by calling
@code{select-window} with argument @var{norecord} @code{nil}.

The order of recently selected windows and the buffer list are not
changed by this macro.
@end defmac

@cindex frame selected window
@cindex window selected within frame
Earlier (@pxref{Basic Windows}) we mentioned that at any time, exactly
one window on any frame is selected within the frame.  The significance
of this designation is that selecting the frame also selects this
window.  Conversely, selecting a window for Emacs with
@code{select-window} also makes that window selected within its frame.

@defun frame-selected-window  &optional frame
This function returns the window on @var{frame} that is selected within
@var{frame}.  The optional argument @var{frame} must denote a live frame
and defaults to the selected one.
@end defun

@defun set-frame-selected-window frame window &optional norecord
This function sets the selected window of frame @var{frame} to
@var{window}.  The argument @var{frame} must denote a live frame and
defaults to the selected one.  If @var{frame} is the selected frame,
this also makes @var{window} the selected window.  The argument
@var{window} must denote a live window.  This function returns
@var{window}.

Optional argument @var{norecord} non-@code{nil} means to neither change
the list of most recently selected windows (@pxref{Selecting Windows})
nor the buffer list (@pxref{The Buffer List}).
@end defun


@node Cyclic Window Ordering
@section Cyclic Ordering of Windows
@cindex cyclic ordering of windows
@cindex ordering of windows, cyclic
@cindex window ordering, cyclic

When you use the command @kbd{C-x o} (@code{other-window}) to select
some other window, it moves through live windows in a specific order.
For any given configuration of windows, this order never varies.  It is
called the @dfn{cyclic ordering of windows}.

   For a particular frame, this ordering is determined by the window
tree of that frame, see @ref{Windows and Frames}.  More precisely, the
ordering is obtained by a depth-first traversal of the frame's window
tree supplemented, if requested, by the frame's minibuffer window.

   If there's just one live frame, the cyclic ordering is the ordering
for that frame.  Otherwise, the cyclic ordering is obtained by appending
the orderings for individual frames in order of the list of all live
frames, @ref{Finding All Frames}.  In any case, the ordering is made
``cyclic'' by having the last window precede the first window in the
ordering.

@defun next-window &optional window minibuf all-frames
@cindex minibuffer window, and @code{next-window}
This function returns the window following @var{window} in the cyclic
ordering of windows.  The argument @var{window} must specify a live
window and defaults to the selected one.

The optional argument @var{minibuf} specifies whether minibuffer windows
shall be included in the cyclic ordering.  Normally, when @var{minibuf}
is @code{nil}, a minibuffer window is included only if it is currently
``active''; this matches the behavior of @kbd{C-x o}.  (Note that a
minibuffer window is active as long as its minibuffer is in use; see
@ref{Minibuffers}).

If @var{minibuf} is @code{t}, the cyclic ordering includes all
minibuffer windows.  If @var{minibuf} is neither @code{t} nor
@code{nil}, minibuffer windows are not included even if they are active.

The optional argument @var{all-frames} specifies which frames to
consider.  Here are the possible values and their meanings:

@itemize @bullet
@item @code{nil}
means consider all windows on @var{window}'s frame, plus the minibuffer
window used by that frame even if it lies in some other frame.  If the
minibuffer counts (as determined by @var{minibuf}), then all windows on
all frames that share that minibuffer count too.

@item @code{t}
means consider all windows on all existing frames.

@item @code{visible}
means consider all windows on all visible frames.  (To get useful
results, ensure that @var{window} is on a visible frame.)

@item 0
means consider all windows on all visible or iconified frames.

@item A frame
means consider all windows on that frame.

@item Anything else
means consider the windows on @var{window}'s frame, and no others.
@end itemize

This example assumes there are two windows, both displaying the
buffer @samp{windows.texi}:

@example
@group
(selected-window)
     @result{} #<window 56 on windows.texi>
@end group
@group
(next-window (selected-window))
     @result{} #<window 52 on windows.texi>
@end group
@group
(next-window (next-window (selected-window)))
     @result{} #<window 56 on windows.texi>
@end group
@end example
@end defun

@defun previous-window &optional window minibuf all-frames
This function returns the window preceding @var{window} in the cyclic
ordering of windows.  The other arguments specify which windows to
consider as in @code{next-window}.
@end defun

@deffn Command other-window count &optional all-frames
This function selects another window in the cyclic ordering of windows.
@var{count} specifies the number of windows to skip in the ordering,
starting with the selected window, before making the selection.  If
@var{count} is a positive number, it skips @var{count} windows forwards.
@var{count} negative means skip @minus{}@var{count} windows backwards.
If @var{count} is zero, it does not skip any window, thus re-selecting
the selected window.  In an interactive call, @var{count} is the numeric
prefix argument.

The optional argument @var{all-frames} has the same meaning as in
@code{next-window}, but the @var{minibuf} argument of @code{next-window}
is always effectively @code{nil}.  This function returns @code{nil}.

This function does not select a window that has a non-@code{nil}
@code{no-other-window} window parameter (@pxref{Window Parameters}).
@end deffn

The following function returns a copy of the list of windows in the
cyclic odering.

@defun window-list-1 &optional window &optional minibuf &optional all_frames
This function returns a list of live windows.  The optional arguments
@var{minibuf} and @var{all-frames} specify the set of windows to include
in the list.  See the description of @code{next-window} for details.

The optional argument @var{window} specifies the first window to list
and defaults to the selected window.  If @var{window} is not on the list
of windows returned, some other window will be listed first but no error
is signalled.
@end defun

The functions described below use @code{window-list-1} for generating a
copy of the list of all relevant windows.  Hence, any change of the
window configuration that occurs while one of these functions is
executed is @emph{not} reflected in the list of windows investigated.

@defun walk-windows proc &optional minibuf all-frames
This function cycles through live windows.  It calls the function
@var{proc} once for each window, with the window as its sole argument.

The optional arguments @var{minibuf} and @var{all-frames} specify the
set of windows to include in the walk, see @code{next-window} above.  If
@var{all-frames} specifies a frame, the first window walked is the first
window on that frame as returned by @code{frame-first-window} and not
necessarily the selected window.

If @var{proc} changes the window configuration by splitting or deleting
windows, that change is not reflected in the set of windows walked.
That set is determined entirely by the set of live windows at the time
this function was invoked.
@end defun

The following function allows to determine whether a specific window is
the only live window.

@defun one-window-p &optional no-mini all-frames
This function returns non-@code{nil} if the selected window is the only
window.

The optional argument @var{no-mini}, if non-@code{nil}, means don't
count the minibuffer even if it is active; otherwise, the minibuffer
window is counted when it is active.  The optional argument
@var{all-frames} has the same meaning as for @code{next-window}, see
above.
@end defun

@cindex finding windows
  The following functions choose (but do not select) one of the windows
on the screen, offering various criteria for the choice.

@cindex least recently used window
@defun get-lru-window &optional all-frames dedicated
This function returns the window least recently ``used'' (that is,
selected).  If any full-width windows are present, it only considers
these.  The optional argument @var{all-frames} has the same meaning as
in @code{next-window}.

The selected window is returned if it is the only candidate.  A
minibuffer window is never a candidate.  A dedicated window
(@pxref{Dedicated Windows}) is never a candidate unless the optional
argument @var{dedicated} is non-@code{nil}.
@end defun

@cindex largest window
@defun get-largest-window &optional all-frames dedicated
This function returns the window with the largest area (height times
width).  A minibuffer window is never a candidate.  A dedicated window
(@pxref{Dedicated Windows}) is never a candidate unless the optional
argument @var{dedicated} is non-@code{nil}.

If there are two candidate windows of the same size, this function
prefers the one that comes first in the cyclic ordering of windows,
starting from the selected window.

The optional argument @var{all-frames} specifies which set of windows to
consider as with @code{next-window}, see above.
@end defun

@cindex window that satisfies a predicate
@cindex conditional selection of windows
@defun get-window-with-predicate predicate &optional minibuf all-frames default
This function returns a window satisfying @var{predicate}.  It cycles
through all visible windows calling @var{predicate} on each one of them
with that window as its argument.  The function returns the first window
for which @var{predicate} returns a non-@code{nil} value; if that never
happens, it returns @var{default} (which defaults to @code{nil}).

The optional arguments @var{minibuf} and @var{all-frames} specify the
set of windows to investigate.  See the description of
@code{next-window} for details.
@end defun

@node Buffers and Windows
@section Buffers and Windows
@cindex examining windows
@cindex windows, controlling precisely
@cindex buffers, controlled in windows

To find out which buffer is displayed in a given window the following
function is used.

@defun window-buffer &optional window
This function returns the buffer that @var{window} is displaying.  The
argument @var{window} can be any window and defaults to the selected
one.  If @var{window} is an internal window, this function returns
@code{nil}.
@end defun

The basic, low-level function to associate a window with a buffer is
@code{set-window-buffer}.  Higher-level functions like
@code{switch-to-buffer} and @code{display-buffer} try to obey a number
of user customizations regulating which windows are supposed to
display which buffers.  @xref{Switching Buffers}.  When writing an
application, you should avoid using @code{set-window-buffer} unless
you are sure you need it.

@defun set-window-buffer window buffer-or-name &optional keep-margins
This function makes @var{window} display @var{buffer-or-name} and
returns @code{nil}.  The argument @var{window} has to denote a live
window and defaults to the selected one.  The argument
@var{buffer-or-name} must specify a buffer or the name of an existing
buffer.  An error is signalled when @var{window} is @dfn{strongly}
dedicated to its buffer (@pxref{Dedicated Windows}) and does not already
display @var{buffer-or-name}.

Normally, displaying @var{buffer-or-name} in @var{window} resets the
window's position, display margins, fringe widths, and scroll bar
settings based on the local variables of the specified buffer.  However,
if the optional argument @var{keep-margins} is non-@code{nil}, display
margins and fringe widths of @var{window} remain unchanged.
@xref{Fringes}.

This function is the fundamental primitive for changing which buffer is
displayed in a window, and all ways of doing that call this function.
Neither the selected window nor the current buffer are changed by this
function.

This function runs @code{window-scroll-functions} before running
@code{window-configuration-change-hook}, see @ref{Window Hooks}.
@end defun

@defvar buffer-display-count
This buffer-local variable records the number of times a buffer has been
displayed in a window.  It is incremented each time
@code{set-window-buffer} is called for the buffer.
@end defvar

@defvar buffer-display-time
This variable records the time at which a buffer was last made visible
in a window.  It is always local in each buffer; each time
@code{set-window-buffer} is called, it sets this variable to
@code{(current-time)} in the specified buffer (@pxref{Time of Day}).
When a buffer is first created, @code{buffer-display-time} starts out
with the value @code{nil}.
@end defvar

@defun get-buffer-window &optional buffer-or-name all-frames
This function returns a window displaying @var{buffer-or-name}, or
@code{nil} if there is none.  If there are several such windows, then
the function returns the first one in the cyclic ordering of windows,
starting from the selected window, @xref{Cyclic Window Ordering}.

The argument @var{buffer-or-name} may be a buffer or a buffer name and
defaults to the current buffer.  The optional argument @var{all-frames}
specifies which windows to consider:

@itemize @bullet
@item
@code{nil} means consider windows on the selected frame.
@item
@code{t} means consider windows on all existing frames.
@item
@code{visible} means consider windows on all visible frames.
@item
0 means consider windows on all visible or iconified frames.
@item
A frame means consider windows on that frame only.
@end itemize

Observe that the behavior of @code{get-buffer-window} may differ from
that of @code{next-window} (@pxref{Cyclic Window Ordering}) when
@var{all-frames} equals @code{nil} or any value not listed here.
Perhaps we will change @code{get-buffer-window} in the future to make it
compatible with the other functions.
@end defun

@defun get-buffer-window-list &optional buffer-or-name minibuf all-frames
This function returns a list of all windows currently displaying
@var{buffer-or-name}.  The argument @var{buffer-or-name} may be a buffer
or the name of an existing buffer and defaults to the current buffer.

The two remaining arguments work like the same-named arguments of
@code{next-window} (@pxref{Cyclic Window Ordering}); they are @emph{not}
like the optional arguments of @code{get-buffer-window}.
@end defun

@deffn Command replace-buffer-in-windows &optional buffer-or-name
This command replaces @var{buffer-or-name} with some other buffer, in
all windows displaying it.  For each such window, it choose another
buffer using @code{switch-to-prev-buffer} (@pxref{Window History}).

@var{buffer-or-name} may be a buffer, or the name of an existing
buffer; it defaults to the current buffer.

If a window displaying @var{buffer-or-name} is dedicated
(@pxref{Dedicated Windows}), has never displayed any other buffers and
is not the only window on its frame, that window is deleted.  If that
window is the only window on its frame and there are other frames on the
frame's terminal, that frame is deleted too; otherwise, the buffer
provided by the function @code{switch-to-prev-buffer} (@pxref{Window
History}) is displayed instead.
@end deffn


@node Switching Buffers
@section Switching to a Buffer in a Window
@cindex switching to a buffer
@cindex displaying a buffer

  This section describes high-level functions for switching to a
specified buffer in some window.

  Do @emph{not} use these functions to make a buffer temporarily
current just so a Lisp program can access or modify it.  They have
side-effects, such as changing window histories (@pxref{Window
History}), which will surprise the user if used that way.  If you want
to make a buffer current to modify it in Lisp, use
@code{with-current-buffer}, @code{save-current-buffer}, or
@code{set-buffer}.  @xref{Current Buffer}.

@deffn Command switch-to-buffer buffer-or-name &optional norecord force-same-window
This function displays @var{buffer-or-name} in the selected window,
and makes it the current buffer.  (In contrast, @code{set-buffer}
makes the buffer current but does not display it; @pxref{Current
Buffer}).  It is often used interactively (as the binding of @kbd{C-x
b}), as well as in Lisp programs.  The return value is the buffer
switched to.

If @var{buffer-or-name} is @code{nil}, it defaults to the buffer
returned by @code{other-buffer} (@pxref{The Buffer List}).  If
@var{buffer-or-name} is a string that is not the name of any existing
buffer, this function creates a new buffer with that name; the new
buffer's major mode is determined by the variable @code{major-mode}
(@pxref{Major Modes}).

Normally the specified buffer is put at the front of the buffer
list---both the global buffer list and the selected frame's buffer
list (@pxref{The Buffer List}).  However, this is not done if the
optional argument @var{norecord} is non-@code{nil}.

If this function is unable to display the buffer in the selected
window---usually because the selected window is a minibuffer window or
is strongly dedicated to its buffer (@pxref{Dedicated Windows})---then
it normally tries to display the buffer in some other window, in the
manner of @code{pop-to-buffer} (see below).  However, if the optional
argument @var{force-same-window} is non-@code{nil}, it signals an error
instead.
@end deffn

The next two functions are similar to @code{switch-to-buffer}, except
for the described features.

@deffn Command switch-to-buffer-other-window buffer-or-name &optional norecord
This function makes the buffer specified by @var{buffer-or-name}
current and displays it in some window other than the selected window.
It uses the function @code{pop-to-buffer} internally (see below).

If the selected window already displays the specified buffer, it
continues to do so, but another window is nonetheless found to display
it as well.

The @var{buffer-or-name} and @var{norecord} arguments have the same
meanings as in @code{switch-to-buffer}.
@end deffn

@deffn Command switch-to-buffer-other-frame buffer-or-name &optional norecord
This function makes the buffer specified by @var{buffer-or-name}
current and displays it, usually in a new frame.  It uses the function
@code{pop-to-buffer} (see below).

If the specified buffer is already displayed in another window, in any
frame on the current terminal, this switches to that window instead of
creating a new frame.  However, the selected window is never used for
this.

The @var{buffer-or-name} and @var{norecord} arguments have the same
meanings as in @code{switch-to-buffer}.
@end deffn

The above commands use @code{pop-to-buffer}, which is the function
used by Lisp programs to flexibly display a buffer in some window and
select that window for editing:

@defun pop-to-buffer buffer-or-name &optional action norecord
This function makes @var{buffer-or-name} the current buffer and
displays it in some window, preferably not the window previously
selected.  It then selects the displaying window.  If that window is
on a different graphical frame, that frame is given input focus if
possible (@pxref{Input Focus}).  The return value is the buffer that
was switched to.

This function uses @code{display-buffer} to display the buffer, so all
the variables affecting @code{display-buffer} will affect it as well.
@xref{Choosing Window}.

If @var{buffer-or-name} is @code{nil}, it defaults to the buffer
returned by @code{other-buffer} (@pxref{The Buffer List}).  If
@var{buffer-or-name} is a string that is not the name of any existing
buffer, this function creates a new buffer with that name; the new
buffer's major mode is determined by the variable @code{major-mode}
(@pxref{Major Modes}).

If @var{action} is non-@code{nil}, it should be a display action to
pass to @code{display-buffer} (@pxref{Choosing Window}).
Alternatively, a non-@code{nil}, non-list value means to pop to a
window other than the selected one---even if the buffer is already
displayed in the selected window.

Like @code{switch-to-buffer}, this function updates the buffer list
unless @var{norecord} is non-@code{nil}.
@end defun

@node Choosing Window
@section Choosing a Window for Display

  The command @code{display-buffer} flexibly chooses a window for
display, and displays a specified buffer in that window.  It can be
called interactively, via the key binding @kbd{C-x 4 o}.  It is also
used as a subroutine by many functions and commands, including
@code{switch-to-buffer} and @code{pop-to-buffer} (@pxref{Switching
Buffers}).

@cindex display action
@cindex action function, for display-buffer
@cindex action alist, for display-buffer
  This command performs several complex steps to find a window to
display in.  These steps are described by means of @dfn{display
actions}, which have the form @code{(@var{function} . @var{alist})}.
Here, @var{function} is either a function or a list of functions,
which we refer to as @dfn{action functions}; @var{alist} is an
association list, which we refer to as @dfn{action alists}.

  An action function accepts two arguments: the buffer to display and
an action alist.  It attempts to display the buffer in some window,
picking or creating a window according to its own criteria.  If
successful, it returns the window; otherwise, it returns @code{nil}.
@xref{Display Action Functions}, for a list of predefined action
functions.

  @code{display-buffer} works by combining display actions from
several sources, and calling the action functions in turn, until one
of them manages to display the buffer and returns a non-@code{nil}
value.

@deffn Command display-buffer buffer-or-name &optional action frame
This command makes @var{buffer-or-name} appear in some window, without
selecting the window or making the buffer current.  The argument
@var{buffer-or-name} must be a buffer or the name of an existing
buffer.  The return value is the window chosen to display the buffer.

The optional argument @var{action}, if non-@code{nil}, should normally
be a display action (described above).  @code{display-buffer} builds a
list of action functions and an action alist, by consolidating display
actions from the following sources (in order):

@itemize
@item
The variable @code{display-buffer-overriding-action}.

@item
The user option @code{display-buffer-alist}.

@item
The @var{action} argument.

@item
The user option @code{display-buffer-base-action}.

@item
The constant @code{display-buffer-fallback-action}.
@end itemize

@noindent
Each action function is called in turn, passing the buffer as the
first argument and the combined action alist as the second argument,
until one of the functions returns non-nil.

The argument @var{action} can also have a non-@code{nil}, non-list
value.  This has the special meaning that the buffer should be
displayed in a window other than the selected one, even if the
selected window is already displaying it.  If called interactively
with a prefix argument, @var{action} is @code{t}.

The optional argument @var{frame}, if non-@code{nil}, specifies which
frames to check when deciding whether the buffer is already displayed.
It is equivalent to adding an element @code{(reusable-frames
. @var{frame})} to the action alist of @var{action}.  @xref{Display
Action Functions}.
@end deffn

@defvar display-buffer-overriding-action
The value of this variable should be a display action, which is
treated with the highest priority by @code{display-buffer}.  The
default value is empty, i.e. @code{(nil . nil)}.
@end defvar

@defopt display-buffer-alist
The value of this option is an alist mapping regular expressions to
display actions.  If the name of the buffer passed to
@code{display-buffer} matches a regular expression in this alist, then
@code{display-buffer} uses the corresponding display action.
@end defopt

@defopt display-buffer-base-action
The value of this option should be a display action.  This option can
be used to define a ``standard'' display action for calls to
@code{display-buffer}.
@end defopt

@defvr Constant display-buffer-fallback-action
This display action specifies the fallback behavior for
@code{display-buffer} if no other display actions are given.
@end defvr

@node Display Action Functions
@section Action Functions for @code{display-buffer}

The following basic action functions are defined in Emacs.  Each of
these functions takes two arguments: @var{buffer}, the buffer to
display, and @var{alist}, an action alist.  Each action function
returns the window if it succeeds, and @code{nil} if it fails.

@defun display-buffer-same-window buffer alist
This function tries to display @var{buffer} in the selected window.
It fails if the selected window is a minibuffer window or is dedicated
to another buffer (@pxref{Dedicated Windows}).  It also fails if
@var{alist} has a non-nil @code{inhibit-same-window} entry.
@end defun

@defun display-buffer-reuse-window buffer alist
This function tries to ``display'' @var{buffer} by finding a window
that is already displaying it.

If @var{alist} has a non-@code{nil} @code{inhibit-same-window} entry,
the selected window is not eligible for reuse.

If @var{alist} contains a @code{reusable-frames} entry, its value
determines which frames to search for a reusable window:

@itemize @bullet
@item
@code{nil} means consider windows on the selected frame.
(Actually, the last non-minibuffer frame.)
@item
@code{t} means consider windows on all frames.
@item
@code{visible} means consider windows on all visible frames.
@item
0 means consider windows on all visible or iconified frames.
@item
A frame means consider windows on that frame only.
@end itemize

If @var{alist} contains no @code{reusable-frames} entry, this function
normally searches just the selected frame; however, if either the
variable @code{display-buffer-reuse-frames} or the variable
@code{pop-up-frames} is non-@code{nil}, it searches all frames on the
current terminal.  @xref{Choosing Window Options}.
@end defun

@defun display-buffer-pop-up-frame buffer alist
This function creates a new frame, and displays the buffer in that
frame's window.
@end defun

@defun display-buffer-pop-up-window buffer alist
This function tries to display @var{buffer} by splitting the selected
window.  It uses @code{split-window-sensibly} as a subroutine
(@pxref{Choosing Window Options}).
@end defun

@defun display-buffer-use-some-window buffer alist
This function tries to display @var{buffer} by choosing an existing
window and displaying the buffer in that window.  It can fail if all
windows are dedicated to another buffer (@pxref{Dedicated Windows}).
@end defun

@node Choosing Window Options
@section Additional Options for Displaying Buffers

The behavior of the standard display actions of @code{display-buffer}
(@pxref{Choosing Window}) can be modified by a variety of user
options.

@defopt display-buffer-reuse-frames
If this variable is non-@code{nil}, @code{display-buffer} searches
visible and iconified frames for a window displaying
@var{buffer-or-name}.  If there is such a window, @code{display-buffer}
makes that window's frame visible and raises it if necessary, and
returns the window.  If there is no such window or
@code{display-buffer-reuse-frames} is @code{nil}, the behavior of
@code{display-buffer} is determined by the variables described next.
@end defopt

@defopt pop-up-windows
This variable specifies whether @code{display-buffer} is allowed to
split (@pxref{Splitting Windows}) an existing window.  If this variable
is non-@code{nil}, @code{display-buffer} tries to split the largest or
least recently used window on the selected frame.  (If the selected
frame is a minibuffer-only frame, @code{display-buffer} tries to split a
window on another frame instead.)  If this variable is @code{nil} or the
variable @code{pop-up-frames} (see below) is non-@code{nil},
@code{display-buffer} does not split any window.
@end defopt

@defopt split-window-preferred-function
This variable must specify a function with one argument, which is a
window.  The @code{display-buffer} routines will call this function with
one or more candidate windows when they look for a window to split.  The
function is expected to split that window and return the new window.  If
the function returns @code{nil}, this means that the argument window
cannot (or shall not) be split.

The default value of @code{split-window-preferred-function} is the
function @code{split-window-sensibly} described below.  If you
customize this option, bear in mind that the @code{display-buffer}
routines may call your function up to two times when trying to split a
window.  The argument of the first call is the largest window on the
chosen frame (as returned by @code{get-largest-window}).  If that call
fails to return a live window, your function is called a second time
with the least recently used window on that frame (as returned by
@code{get-lru-window}).

The function specified by this option may try to split any other window
instead of the argument window.  Note that the window selected at the
time @code{display-buffer} was invoked is still selected when your
function is called.  Hence, you can split the selected window (instead
of the largest or least recently used one) by simply ignoring the window
argument in the body of your function.  You can even choose to not split
any window as long as the return value of your function specifies a live
window or @code{nil}, but you are not encouraged to do so
unconditionally.  If you want @code{display-buffer} to never split any
windows, set @code{pop-up-windows} to @code{nil}.
@end defopt

@defun split-window-sensibly window
This function takes a window as argument and tries to split that window
in a suitable way.  The two variables described next are useful for
tuning the behavior of this function.
@end defun

@defopt split-height-threshold
This variable specifies whether @code{split-window-sensibly} may split
windows vertically.  If it is an integer, @code{split-window-sensibly}
tries to vertically split a window only if it has at least this many
lines.  If the window has less lines, splitting fails, or the value of
this variable is @code{nil}, @code{split-window-sensibly} will try to
split the window horizontally, subject to restrictions of
@code{split-width-threshold} (see below).  If splitting horizontally
fails too and the window is the only window on its frame,
@code{split-window-sensibly} will try to split the window vertically
disregarding the value of @code{split-height-threshold}.  If this fails
as well, @code{split-window-sensibly} returns @code{nil}.

@code{split-window-sensibly} does not split vertically a window whose
height is fixed (@pxref{Resizing Windows}).  Also, it vertically splits
a window only if the space taken up by that window can accommodate two
windows one above the other that are both at least
@code{window-min-height} lines tall.  Moreover, if the window that shall
be split has a mode line, @code{split-window-sensibly} does not split
the window unless the new window can accommodate a mode line too.
@end defopt

@defopt split-width-threshold
This variable specifies whether @code{split-window-sensibly} may split
windows horizontally.  If it is an integer, @code{split-window-sensibly}
tries to horizontally split a window only if it has at least this many
columns.  If it is @code{nil}, @code{split-window-sensibly} will not
split the window horizontally.  (It still might split the window
vertically, though, see above.)

@code{split-window-sensibly} does not split horizontally a window if
that window's width is fixed (@pxref{Resizing Windows}).  Also, it
horizontally splits a window only if the space that window takes up can
accommodate two windows side by side that are both at least
@code{window-min-width} columns wide.
@end defopt

@defopt even-window-heights
This variable specifies whether @code{display-buffer} should even out
window heights if the buffer gets displayed in an existing window, above
or beneath another window.  If @code{even-window-heights} is
non-@code{nil}, the default, window heights will be evened out.  If
either of the involved window has fixed height (@pxref{Resizing
Windows}) or @code{even-window-heights} is @code{nil}, the original
window heights will be left alone.
@end defopt

@c Emacs 19 feature
@defopt pop-up-frames
This variable specifies whether @code{display-buffer} should make new
frames.  If it is non-@code{nil}, @code{display-buffer} looks for a
window already displaying @var{buffer-or-name} on any visible or
iconified frame.  If it finds such a window, it makes that window's
frame visible and raises it if necessary, and returns the window.
Otherwise it makes a new frame, unless the variable's value is
@code{graphic-only} and the selected frame is not on a graphic display.
@xref{Frames}, for more information.

Note that the value of @code{pop-up-windows} does not matter if
@code{pop-up-frames} is non-@code{nil}.  If @code{pop-up-frames} is
@code{nil}, then @code{display-buffer} either splits a window or reuses
one.
@end defopt

@c Emacs 19 feature
@defopt pop-up-frame-function
This variable specifies how to make a new frame if @code{pop-up-frames}
is non-@code{nil}.

The value of this variable must be a function of no arguments.  When
@code{display-buffer} makes a new frame, it does so by calling that
function, which should return a frame.  The default value of this
variable is a function that creates a frame using the parameters
specified by @code{pop-up-frame-alist} described next.
@end defopt

@defopt pop-up-frame-alist
This variable holds an alist specifying frame parameters used by the
default value of @code{pop-up-frame-function} for making new frames.
@xref{Frame Parameters}, for more information about frame parameters.
@end defopt

@defopt special-display-buffer-names
A list of buffer names identifying buffers that should be displayed
specially.  If the name of @var{buffer-or-name} is in this list,
@code{display-buffer} handles the buffer specially.  By default, special
display means to give the buffer a dedicated frame.

If an element is a list, instead of a string, then the @sc{car} of that
list is the buffer name, and the rest of that list says how to create
the frame.  There are two possibilities for the rest of that list (its
@sc{cdr}): It can be an alist, specifying frame parameters, or it can
contain a function and arguments to give to it.  (The function's first
argument is always the buffer to be displayed; the arguments from the
list come after that.)

For example:

@example
(("myfile" (minibuffer) (menu-bar-lines . 0)))
@end example

@noindent
specifies to display a buffer named @samp{myfile} in a dedicated frame
with specified @code{minibuffer} and @code{menu-bar-lines} parameters.

The list of frame parameters can also use the phony frame parameters
@code{same-frame} and @code{same-window}.  If the specified frame
parameters include @code{(same-window . @var{value})} and @var{value}
is non-@code{nil}, that means to display the buffer in the current
selected window.  Otherwise, if they include @code{(same-frame .
@var{value})} and @var{value} is non-@code{nil}, that means to display
the buffer in a new window in the currently selected frame.
@end defopt

@defopt special-display-regexps
A list of regular expressions specifying buffers that should be
displayed specially.  If the buffer's name matches any of the regular
expressions in this list, @code{display-buffer} handles the buffer
specially.  By default, special display means to give the buffer a
dedicated frame.

If an element is a list, instead of a string, then the @sc{car} of the
list is the regular expression, and the rest of the list says how to
create the frame.  See @code{special-display-buffer-names} above.
@end defopt

@defun special-display-p buffer-name
This function returns non-@code{nil} if displaying a buffer
named @var{buffer-name} with @code{display-buffer} would
create a special frame.  The value is @code{t} if it would
use the default frame parameters, or else the specified list
of frame parameters.
@end defun

@defopt special-display-function
This variable holds the function to call to display a buffer specially.
It receives the buffer as an argument, and should return the window in
which it is displayed.  The default value of this variable is
@code{special-display-popup-frame}, see below.
@end defopt

@defun special-display-popup-frame buffer &optional args
This function tries to make @var{buffer} visible in a frame of its own.
If @var{buffer} is already displayed in some window, it makes that
window's frame visible and raises it.  Otherwise, it creates a frame
that is dedicated to @var{buffer}.  The return value is the window used
to display @var{buffer}.

If @var{args} is an alist, it specifies frame parameters for the new
frame.  If @var{args} is a list whose @sc{car} is a symbol, then
@code{(car @var{args})} is called as a function to actually create and
set up the frame; it is called with @var{buffer} as first argument, and
@code{(cdr @var{args})} as additional arguments.

This function always uses an existing window displaying @var{buffer},
whether or not it is in a frame of its own; but if you set up the above
variables in your init file, before @var{buffer} was created, then
presumably the window was previously made by this function.
@end defun

@defopt special-display-frame-alist
@anchor{Definition of special-display-frame-alist}
This variable holds frame parameters for
@code{special-display-popup-frame} to use when it creates a frame.
@end defopt

@defopt same-window-buffer-names
A list of buffer names for buffers that should be displayed in the
selected window.  If the buffer's name is in this list,
@code{display-buffer} handles the buffer by switching to it in the
selected window.
@end defopt

@defopt same-window-regexps
A list of regular expressions that specify buffers that should be
displayed in the selected window.  If the buffer's name matches any of
the regular expressions in this list, @code{display-buffer} handles the
buffer by switching to it in the selected window.
@end defopt

@defun same-window-p buffer-name
This function returns @code{t} if displaying a buffer
named @var{buffer-name} with @code{display-buffer} would
put it in the selected window.
@end defun

@c Emacs 19 feature
@defopt display-buffer-function
This variable is the most flexible way to customize the behavior of
@code{display-buffer}.  If it is non-@code{nil}, it should be a function
that @code{display-buffer} calls to do the work.  The function should
accept two arguments, the first two arguments that @code{display-buffer}
received.  It should choose or create a window, display the specified
buffer in it, and then return the window.

This variable takes precedence over all the other options described
above.
@end defopt

If all options described above fail to produce a suitable window,
@code{display-buffer} tries to reuse an existing window.  As a last
resort, it will try to display @var{buffer-or-name} on a separate frame.
In that case, the value of @code{pop-up-frames} is disregarded.


@node Window History
@section Window History
@cindex window history

Each window remembers the buffers it has displayed earlier and the order
in which these buffers have been removed from it.  This history is used,
for example, by @code{replace-buffer-in-windows} (@pxref{Buffers and
Windows}).  This list is automatically maintained by Emacs, but you can
use the following functions to explicitly inspect or alter it:

@defun window-prev-buffers &optional window
This function returns a list specifying the previous contents of
@var{window}, which should be a live window and defaults to the
selected window.

Each list element has the form @code{(@var{buffer} @var{window-start}
@var{window-pos})}, where @var{buffer} is a buffer previously shown in
the window, @var{window-start} is the window start position when that
buffer was last shown, and @var{window-pos} is the point position when
that buffer was last shown.

The list is ordered so that earlier elements correspond to more
recently-shown buffers, and the first element usually corresponds to the
buffer most recently removed from the window.
@end defun

@defun set-window-prev-buffers window prev-buffers
This function sets @var{window}'s previous buffers to the value of
@var{prev-buffers}.  The argument @var{window} must be a live window
and defaults to the selected one.  The argument @var{prev-buffers}
should be a list of the same form as that returned by
@code{window-prev-buffers}.
@end defun

In addition, each buffer maintains a list of @dfn{next buffers}, which
is a list of buffers re-shown by @code{switch-to-prev-buffer} (see
below).  This list is mainly used by @code{switch-to-prev-buffer} and
@code{switch-to-next-buffer} for choosing buffers to switch to.

@defun window-next-buffers &optional window
This function returns the list of buffers recently re-shown in
@var{window} via @code{switch-to-prev-buffer}.  The @var{window}
argument must denote a live window or @code{nil} (meaning the selected
window).
@end defun

@defun set-window-next-buffers window next-buffers
This function sets the next buffer list of @var{window} to
@var{next-buffers}.  The @var{window} argument should be a live window
or @code{nil} (meaning the selected window).  The argument
@var{next-buffers} should be a list of buffers.
@end defun

The following commands can be used to cycle through the global buffer
list, much like @code{bury-buffer} and @code{unbury-buffer}.  However,
they cycle according to the specified window's history list, rather
than the global buffer list.  In addition, they restore
window-specific window start and point positions, and may show a
buffer even if it is already shown in another window.  The
@code{switch-to-prev-buffer} command, in particular, is used by
@code{replace-buffer-in-windows}, @code{bury-buffer} and
@code{quit-window} to find a replacement buffer for a window.

@deffn Command switch-to-prev-buffer &optional window bury-or-kill
This command displays the previous buffer in @var{window}.  The
argument @var{window} should be a live window or @code{nil} (meaning
the selected window).  If the optional argument @var{bury-or-kill} is
non-@code{nil}, this means that the buffer currently shown in
@var{window} is about to be buried or killed and consequently shall
not be switched to in future invocations of this command.

The previous buffer is usually the buffer shown before the buffer
currently shown in @var{window}.  However, a buffer that has been buried
or killed or has been already shown by a recent invocation of
@code{switch-to-prev-buffer} does not qualify as previous buffer.

If repeated invocations of this command have already shown all buffers
previously shown in @var{window}, further invocations will show buffers
from the buffer list of the frame @var{window} appears on (@pxref{The
Buffer List}).
@end deffn

@deffn Command switch-to-next-buffer &optional window
This command switches to the next buffer in @var{window} thus undoing
the effect of the last @code{switch-to-prev-buffer} command in
@var{window}.  The argument @var{window} must be a live window and
defaults to the selected one.

If there is no recent invocation of a @code{switch-to-prev-buffer} that
can be undone, this function tries to show a buffer from the buffer list
of the frame @var{window} appears on (@pxref{The Buffer List}).
@end deffn


@node Dedicated Windows
@section Dedicated Windows
@cindex dedicated window

Functions for displaying a buffer can be told to not use specific
windows by marking these windows as @dfn{dedicated} to their buffers.
@code{display-buffer} (@pxref{Choosing Window}) never uses a dedicated
window for displaying another buffer in it.  @code{get-lru-window} and
@code{get-largest-window} (@pxref{Selecting Windows}) do not consider
dedicated windows as candidates when their @var{dedicated} argument is
non-@code{nil}.  The behavior of @code{set-window-buffer}
(@pxref{Buffers and Windows}) with respect to dedicated windows is
slightly different, see below.

When @code{delete-windows-on} (@pxref{Deleting Windows}) wants to
delete a dedicated window and that window is the only window on its
frame, it deletes the window's frame too, provided there are other
frames left.  @code{replace-buffer-in-windows} (@pxref{Switching
Buffers}) tries to delete all dedicated windows showing its buffer
argument.  When such a window is the only window on its frame, that
frame is deleted, provided there are other frames left.  If there are
no more frames left, some other buffer is displayed in the window, and
the window is marked as non-dedicated.

When you kill a buffer (@pxref{Killing Buffers}) displayed in a
dedicated window, any such window usually gets deleted too, since
@code{kill-buffer} calls @code{replace-buffer-in-windows} for cleaning
up windows.  Burying a buffer (@pxref{The Buffer List}) deletes the
selected window if it is dedicated to that buffer.  If, however, that
window is the only window on its frame, @code{bury-buffer} displays
another buffer in it and iconifies the frame.

@defun window-dedicated-p &optional window
This function returns non-@code{nil} if @var{window} is dedicated to its
buffer and @code{nil} otherwise.  More precisely, the return value is
the value assigned by the last call of @code{set-window-dedicated-p} for
@var{window} or @code{nil} if that function was never called with
@var{window} as its argument.  The default for @var{window} is the
selected window.
@end defun

@defun set-window-dedicated-p window flag
This function marks @var{window} as dedicated to its buffer if
@var{flag} is non-@code{nil}, and non-dedicated otherwise.

As a special case, if @var{flag} is @code{t}, @var{window} becomes
@dfn{strongly} dedicated to its buffer.  @code{set-window-buffer}
signals an error when the window it acts upon is strongly dedicated to
its buffer and does not already display the buffer it is asked to
display.  Other functions do not treat @code{t} differently from any
non-@code{nil} value.
@end defun


@node Quitting Windows
@section Quitting Windows

When you want to get rid of a window used for displaying a buffer you
can use the function @code{delete-window} (@pxref{Deleting Windows}) to
remove that window from its frame.  If the buffer has been shown on a
separate frame, you might want to call @code{delete-frame}
(@pxref{Deleting Frames}) instead.  If, on the other hand, a window has
been reused for displaying the buffer, you might prefer showing the
buffer previously shown in that window by calling the function
@code{switch-to-prev-buffer} (@pxref{Window History}).  Finally, you
might want to either bury (@pxref{The Buffer List}) or kill
(@pxref{Killing Buffers}) the window's buffer.

   The following function uses information on how the window for
displaying the buffer was obtained in the first place thus attempting to
automatize the above decisions for you.

@deffn Command quit-window &optional kill window
This command quits @var{window} and buries its buffer.  The argument
@var{window} must be a live window and defaults to the selected one.
With prefix argument @var{kill} non-@code{nil}, it kills the buffer
instead of burying it.

Quitting @var{window} means to proceed as follows: If @var{window} was
created specially for displaying its current buffer, delete @var{window}
provided its frame contains at least one other live window.  If
@var{window} is the only window on its frame and other frames still
exist, delete the frame together with @var{window}.  If, however, there
are no other frames left, display some other buffer in @var{window}.

If @var{window} was reused for displaying its buffer, this command tries
to display the buffer previously shown in it.  It also tries to restore
the window start (@pxref{Window Start and End}) and point (@pxref{Window
Point}) positions of the previously shown buffer.  If, in addition, the
current buffer was temporarily resized, this command will also try to
restore the original height of @var{window}.

The three cases described so far require that the buffer shown in
@var{window} is still the buffer displayed by the last buffer display
function for this window.  If another buffer has been shown in the
meantime or the buffer previously shown no longer exists, this command
calls @code{switch-to-prev-buffer} (@pxref{Window History}) to show some
other buffer instead.
@end deffn

The function @code{quit-window} bases its decisions on information
stored in @var{window}'s @code{quit-restore} window parameter
(@pxref{Window Parameters}) and resets that parameter to @code{nil}
after it's done.


@node Window Point
@section Windows and Point
@cindex window position
@cindex window point
@cindex position in window
@cindex point in window

  Each window has its own value of point (@pxref{Point}), independent of
the value of point in other windows displaying the same buffer.  This
makes it useful to have multiple windows showing one buffer.

@itemize @bullet
@item
The window point is established when a window is first created; it is
initialized from the buffer's point, or from the window point of another
window opened on the buffer if such a window exists.

@item
Selecting a window sets the value of point in its buffer from the
window's value of point.  Conversely, deselecting a window sets the
window's value of point from that of the buffer.  Thus, when you switch
between windows that display a given buffer, the point value for the
selected window is in effect in the buffer, while the point values for
the other windows are stored in those windows.

@item
As long as the selected window displays the current buffer, the window's
point and the buffer's point always move together; they remain equal.
@end itemize

@cindex cursor
   As far as the user is concerned, point is where the cursor is, and
when the user switches to another buffer, the cursor jumps to the
position of point in that buffer.

@defun window-point &optional window
This function returns the current position of point in @var{window}.
For a nonselected window, this is the value point would have (in that
window's buffer) if that window were selected.  The default for
@var{window} is the selected window.

When @var{window} is the selected window and its buffer is also the
current buffer, the value returned is the same as point in that buffer.
Strictly speaking, it would be more correct to return the ``top-level''
value of point, outside of any @code{save-excursion} forms.  But that
value is hard to find.
@end defun

@defun set-window-point window position
This function positions point in @var{window} at position
@var{position} in @var{window}'s buffer.  It returns @var{position}.

If @var{window} is selected, and its buffer is current,
this simply does @code{goto-char}.
@end defun

@defvar window-point-insertion-type
This variable specifies the marker insertion type (@pxref{Marker
Insertion Types}) of @code{window-point}.  The default is @code{nil},
so @code{window-point} will stay behind text inserted there.
@end defvar

@node Window Start and End
@section The Window Start and End Positions
@cindex window start position

  Each window maintains a marker used to keep track of a buffer position
that specifies where in the buffer display should start.  This position
is called the @dfn{display-start} position of the window (or just the
@dfn{start}).  The character after this position is the one that appears
at the upper left corner of the window.  It is usually, but not
inevitably, at the beginning of a text line.

  After switching windows or buffers, and in some other cases, if the
window start is in the middle of a line, Emacs adjusts the window
start to the start of a line.  This prevents certain operations from
leaving the window start at a meaningless point within a line.  This
feature may interfere with testing some Lisp code by executing it
using the commands of Lisp mode, because they trigger this
readjustment.  To test such code, put it into a command and bind the
command to a key.

@defun window-start &optional window
@cindex window top line
This function returns the display-start position of window
@var{window}.  If @var{window} is @code{nil}, the selected window is
used.  For example,

@example
@group
(window-start)
     @result{} 7058
@end group
@end example

When you create a window, or display a different buffer in it, the
display-start position is set to a display-start position recently used
for the same buffer, or to @code{point-min} if the buffer doesn't have
any.

Redisplay updates the window-start position (if you have not specified
it explicitly since the previous redisplay)---to make sure point appears
on the screen.  Nothing except redisplay automatically changes the
window-start position; if you move point, do not expect the window-start
position to change in response until after the next redisplay.

For a realistic example of using @code{window-start}, see the
description of @code{count-lines}.  @xref{Definition of count-lines}.
@end defun

@cindex window end position
@defun window-end &optional window update
This function returns the position where display of its buffer ends in
@var{window}.  The default for @var{window} is the selected window.

Simply changing the buffer text or moving point does not update the
value that @code{window-end} returns.  The value is updated only when
Emacs redisplays and redisplay completes without being preempted.

If the last redisplay of @var{window} was preempted, and did not finish,
Emacs does not know the position of the end of display in that window.
In that case, this function returns @code{nil}.

If @var{update} is non-@code{nil}, @code{window-end} always returns an
up-to-date value for where display ends, based on the current
@code{window-start} value.  If a previously saved value of that position
is still valid, @code{window-end} returns that value; otherwise it
computes the correct value by scanning the buffer text.

Even if @var{update} is non-@code{nil}, @code{window-end} does not
attempt to scroll the display if point has moved off the screen, the
way real redisplay would do.  It does not alter the
@code{window-start} value.  In effect, it reports where the displayed
text will end if scrolling is not required.
@end defun

@defun set-window-start window position &optional noforce
This function sets the display-start position of @var{window} to
@var{position} in @var{window}'s buffer.  It returns @var{position}.

The display routines insist that the position of point be visible when a
buffer is displayed.  Normally, they change the display-start position
(that is, scroll the window) whenever necessary to make point visible.
However, if you specify the start position with this function using
@code{nil} for @var{noforce}, it means you want display to start at
@var{position} even if that would put the location of point off the
screen.  If this does place point off screen, the display routines move
point to the left margin on the middle line in the window.

For example, if point @w{is 1} and you set the start of the window
@w{to 37}, the start of the next line, point will be ``above'' the top
of the window.  The display routines will automatically move point if
it is still 1 when redisplay occurs.  Here is an example:

@example
@group
;; @r{Here is what @samp{foo} looks like before executing}
;;   @r{the @code{set-window-start} expression.}
@end group

@group
---------- Buffer: foo ----------
@point{}This is the contents of buffer foo.
2
3
4
5
6
---------- Buffer: foo ----------
@end group

@group
(set-window-start
 (selected-window)
 (save-excursion
   (goto-char 1)
   (forward-line 1)
   (point)))
@result{} 37
@end group

@group
;; @r{Here is what @samp{foo} looks like after executing}
;;   @r{the @code{set-window-start} expression.}
---------- Buffer: foo ----------
2
3
@point{}4
5
6
---------- Buffer: foo ----------
@end group
@end example

If @var{noforce} is non-@code{nil}, and @var{position} would place point
off screen at the next redisplay, then redisplay computes a new window-start
position that works well with point, and thus @var{position} is not used.
@end defun

@defun pos-visible-in-window-p &optional position window partially
This function returns non-@code{nil} if @var{position} is within the
range of text currently visible on the screen in @var{window}.  It
returns @code{nil} if @var{position} is scrolled vertically out of view.
Locations that are partially obscured are not considered visible unless
@var{partially} is non-@code{nil}.  The argument @var{position} defaults
to the current position of point in @var{window}; @var{window}, to the
selected window.  If @var{position} is @code{t}, that means to check the
last visible position in @var{window}.

This function considers only vertical scrolling.  If @var{position} is
out of view only because @var{window} has been scrolled horizontally,
@code{pos-visible-in-window-p} returns non-@code{nil} anyway.
@xref{Horizontal Scrolling}.

If @var{position} is visible, @code{pos-visible-in-window-p} returns
@code{t} if @var{partially} is @code{nil}; if @var{partially} is
non-@code{nil}, and the character following @var{position} is fully
visible, it returns a list of the form @code{(@var{x} @var{y})}, where
@var{x} and @var{y} are the pixel coordinates relative to the top left
corner of the window; otherwise it returns an extended list of the form
@code{(@var{x} @var{y} @var{rtop} @var{rbot} @var{rowh} @var{vpos})},
where @var{rtop} and @var{rbot} specify the number of off-window pixels
at the top and bottom of the row at @var{position}, @var{rowh} specifies
the visible height of that row, and @var{vpos} specifies the vertical
position (zero-based row number) of that row.

Here is an example:

@example
@group
;; @r{If point is off the screen now, recenter it now.}
(or (pos-visible-in-window-p
     (point) (selected-window))
    (recenter 0))
@end group
@end example
@end defun

@defun window-line-height &optional line window
This function returns the height of text line @var{line} in
@var{window}.  If @var{line} is one of @code{header-line} or
@code{mode-line}, @code{window-line-height} returns information about
the corresponding line of the window.  Otherwise, @var{line} is a text
line number starting from 0.  A negative number counts from the end of
the window.  The default for @var{line} is the current line in
@var{window}; the default for @var{window} is the selected window.

If the display is not up to date, @code{window-line-height} returns
@code{nil}.  In that case, @code{pos-visible-in-window-p} may be used
to obtain related information.

If there is no line corresponding to the specified @var{line},
@code{window-line-height} returns @code{nil}.  Otherwise, it returns
a list @code{(@var{height} @var{vpos} @var{ypos} @var{offbot})},
where @var{height} is the height in pixels of the visible part of the
line, @var{vpos} and @var{ypos} are the vertical position in lines and
pixels of the line relative to the top of the first text line, and
@var{offbot} is the number of off-window pixels at the bottom of the
text line.  If there are off-window pixels at the top of the (first)
text line, @var{ypos} is negative.
@end defun

@node Textual Scrolling
@section Textual Scrolling
@cindex textual scrolling
@cindex scrolling textually

  @dfn{Textual scrolling} means moving the text up or down through a
window.  It works by changing the value of the window's display-start
location.  It may also change the value of @code{window-point} to keep
point on the screen.

  Textual scrolling was formerly called ``vertical scrolling,'' but we
changed its name to distinguish it from the new vertical fractional
scrolling feature (@pxref{Vertical Scrolling}).

  In the commands @code{scroll-up} and @code{scroll-down}, the directions
``up'' and ``down'' refer to the motion of the text in the buffer at which
you are looking through the window.  Imagine that the text is
written on a long roll of paper and that the scrolling commands move the
paper up and down.  Thus, if you are looking at text in the middle of a
buffer and repeatedly call @code{scroll-down}, you will eventually see
the beginning of the buffer.

  Some people have urged that the opposite convention be used: they
imagine that the window moves over text that remains in place.  Then
``down'' commands would take you to the end of the buffer.  This view is
more consistent with the actual relationship between windows and the
text in the buffer, but it is less like what the user sees.  The
position of a window on the terminal does not move, and short scrolling
commands clearly move the text up or down on the screen.  We have chosen
names that fit the user's point of view.

  The textual scrolling functions (aside from
@code{scroll-other-window}) have unpredictable results if the current
buffer is different from the buffer that is displayed in the selected
window.  @xref{Current Buffer}.

  If the window contains a row which is taller than the height of the
window (for example in the presence of a large image), the scroll
functions will adjust the window's vertical scroll position to scroll
the partially visible row.  To disable this feature, Lisp code may bind
the variable @code{auto-window-vscroll} to @code{nil} (@pxref{Vertical
Scrolling}).

@deffn Command scroll-up &optional count
This function scrolls the text in the selected window upward
@var{count} lines.  If @var{count} is negative, scrolling is actually
downward.

If @var{count} is @code{nil} (or omitted), then the length of scroll
is @code{next-screen-context-lines} lines less than the usable height of
the window (not counting its mode line).

@code{scroll-up} returns @code{nil}, unless it gets an error
because it can't scroll any further.
@end deffn

@deffn Command scroll-down &optional count
This function scrolls the text in the selected window downward
@var{count} lines.  If @var{count} is negative, scrolling is actually
upward.

If @var{count} is omitted or @code{nil}, then the length of the scroll
is @code{next-screen-context-lines} lines less than the usable height of
the window (not counting its mode line).

@code{scroll-down} returns @code{nil}, unless it gets an error because
it can't scroll any further.
@end deffn

@deffn Command scroll-other-window &optional count
This function scrolls the text in another window upward @var{count}
lines.  Negative values of @var{count}, or @code{nil}, are handled
as in @code{scroll-up}.

You can specify which buffer to scroll by setting the variable
@code{other-window-scroll-buffer} to a buffer.  If that buffer isn't
already displayed, @code{scroll-other-window} displays it in some
window.

When the selected window is the minibuffer, the next window is normally
the one at the top left corner.  You can specify a different window to
scroll, when the minibuffer is selected, by setting the variable
@code{minibuffer-scroll-window}.  This variable has no effect when any
other window is selected.  When it is non-@code{nil} and the
minibuffer is selected, it takes precedence over
@code{other-window-scroll-buffer}.  @xref{Definition of
minibuffer-scroll-window}.

When the minibuffer is active, it is the next window if the selected
window is the one at the bottom right corner.  In this case,
@code{scroll-other-window} attempts to scroll the minibuffer.  If the
minibuffer contains just one line, it has nowhere to scroll to, so the
line reappears after the echo area momentarily displays the message
@samp{Beginning of buffer}.
@end deffn

@c Emacs 19 feature
@defvar other-window-scroll-buffer
If this variable is non-@code{nil}, it tells @code{scroll-other-window}
which buffer's window to scroll.
@end defvar

@defopt scroll-margin
This option specifies the size of the scroll margin---a minimum number
of lines between point and the top or bottom of a window.  Whenever
point gets within this many lines of the top or bottom of the window,
redisplay scrolls the text automatically (if possible) to move point
out of the margin, closer to the center of the window.
@end defopt

@defopt scroll-conservatively
This variable controls how scrolling is done automatically when point
moves off the screen (or into the scroll margin).  If the value is a
positive integer @var{n}, then redisplay scrolls the text up to
@var{n} lines in either direction, if that will bring point back into
proper view.  This behavior is called @dfn{conservative scrolling}.
Otherwise, scrolling happens in the usual way, under the control of
other variables such as @code{scroll-up-aggressively} and
@code{scroll-down-aggressively}.

The default value is zero, which means that conservative scrolling
never happens.
@end defopt

@defopt scroll-down-aggressively
The value of this variable should be either @code{nil} or a fraction
@var{f} between 0 and 1.  If it is a fraction, that specifies where on
the screen to put point when scrolling down.  More precisely, when a
window scrolls down because point is above the window start, the new
start position is chosen to put point @var{f} part of the window
height from the top.  The larger @var{f}, the more aggressive the
scrolling.

A value of @code{nil} is equivalent to .5, since its effect is to center
point.  This variable automatically becomes buffer-local when set in any
fashion.
@end defopt

@defopt scroll-up-aggressively
Likewise, for scrolling up.  The value, @var{f}, specifies how far
point should be placed from the bottom of the window; thus, as with
@code{scroll-up-aggressively}, a larger value scrolls more aggressively.
@end defopt

@defopt scroll-step
This variable is an older variant of @code{scroll-conservatively}.
The difference is that if its value is @var{n}, that permits scrolling
only by precisely @var{n} lines, not a smaller number.  This feature
does not work with @code{scroll-margin}.  The default value is zero.
@end defopt

@defopt scroll-preserve-screen-position
If this option is @code{t}, scrolling which would move the current
point position out of the window chooses the new position of point
so that the vertical position of the cursor is unchanged, if possible.

If it is non-@code{nil} and not @code{t}, then the scrolling functions
always preserve the vertical position of point, if possible.
@end defopt

@defopt next-screen-context-lines
The value of this variable is the number of lines of continuity to
retain when scrolling by full screens.  For example, @code{scroll-up}
with an argument of @code{nil} scrolls so that this many lines at the
bottom of the window appear instead at the top.  The default value is
@code{2}.
@end defopt

@deffn Command recenter &optional count
@cindex centering point
This function scrolls the text in the selected window so that point is
displayed at a specified vertical position within the window.  It does
not ``move point'' with respect to the text.

If @var{count} is a nonnegative number, that puts the line containing
point @var{count} lines down from the top of the window.  If
@var{count} is a negative number, then it counts upward from the
bottom of the window, so that @minus{}1 stands for the last usable
line in the window.  If @var{count} is a non-@code{nil} list, then it
stands for the line in the middle of the window.

If @var{count} is @code{nil}, @code{recenter} puts the line containing
point in the middle of the window, then clears and redisplays the entire
selected frame.

When @code{recenter} is called interactively, @var{count} is the raw
prefix argument.  Thus, typing @kbd{C-u} as the prefix sets the
@var{count} to a non-@code{nil} list, while typing @kbd{C-u 4} sets
@var{count} to 4, which positions the current line four lines from the
top.

With an argument of zero, @code{recenter} positions the current line at
the top of the window.  This action is so handy that some people make a
separate key binding to do this.  For example,

@example
@group
(defun line-to-top-of-window ()
  "Scroll current line to top of window.
Replaces three keystroke sequence C-u 0 C-l."
  (interactive)
  (recenter 0))

(global-set-key [kp-multiply] 'line-to-top-of-window)
@end group
@end example
@end deffn

@node Vertical Scrolling
@section Vertical Fractional Scrolling
@cindex vertical fractional scrolling
@cindex vertical scroll position

   @dfn{Vertical fractional scrolling} means shifting text in a window
up or down by a specified multiple or fraction of a line.  Each window
has a @dfn{vertical scroll position}, which is a number, never less than
zero.  It specifies how far to raise the contents of the window.
Raising the window contents generally makes all or part of some lines
disappear off the top, and all or part of some other lines appear at the
bottom.  The usual value is zero.

   The vertical scroll position is measured in units of the normal line
height, which is the height of the default font.  Thus, if the value is
.5, that means the window contents are scrolled up half the normal line
height.  If it is 3.3, that means the window contents are scrolled up
somewhat over three times the normal line height.

   What fraction of a line the vertical scrolling covers, or how many
lines, depends on what the lines contain.  A value of .5 could scroll a
line whose height is very short off the screen, while a value of 3.3
could scroll just part of the way through a tall line or an image.

@defun window-vscroll &optional window pixels-p
This function returns the current vertical scroll position of
@var{window}.  The default for @var{window} is the selected window.
If @var{pixels-p} is non-@code{nil}, the return value is measured in
pixels, rather than in units of the normal line height.

@example
@group
(window-vscroll)
     @result{} 0
@end group
@end example
@end defun

@defun set-window-vscroll window lines &optional pixels-p
This function sets @var{window}'s vertical scroll position to
@var{lines}.  If @var{window} is @code{nil}, the selected window is
used.  The argument @var{lines} should be zero or positive; if not, it
is taken as zero.


The actual vertical scroll position must always correspond
to an integral number of pixels, so the value you specify
is rounded accordingly.

The return value is the result of this rounding.

@example
@group
(set-window-vscroll (selected-window) 1.2)
     @result{} 1.13
@end group
@end example

If @var{pixels-p} is non-@code{nil}, @var{lines} specifies a number of
pixels.  In this case, the return value is @var{lines}.
@end defun

@defvar auto-window-vscroll
If this variable is non-@code{nil}, the line-move, scroll-up, and
scroll-down functions will automatically modify the vertical scroll
position to scroll through display rows that are taller than the height
of the window, for example in the presence of large images.
@end defvar

@node Horizontal Scrolling
@section Horizontal Scrolling
@cindex horizontal scrolling

  @dfn{Horizontal scrolling} means shifting the image in the window left
or right by a specified multiple of the normal character width.  Each
window has a @dfn{horizontal scroll position}, which is a number, never
less than zero.  It specifies how far to shift the contents left.
Shifting the window contents left generally makes all or part of some
characters disappear off the left, and all or part of some other
characters appear at the right.  The usual value is zero.

  The horizontal scroll position is measured in units of the normal
character width, which is the width of space in the default font.  Thus,
if the value is 5, that means the window contents are scrolled left by 5
times the normal character width.  How many characters actually
disappear off to the left depends on their width, and could vary from
line to line.

  Because we read from side to side in the ``inner loop,'' and from top
to bottom in the ``outer loop,'' the effect of horizontal scrolling is
not like that of textual or vertical scrolling.  Textual scrolling
involves selection of a portion of text to display, and vertical
scrolling moves the window contents contiguously; but horizontal
scrolling causes part of @emph{each line} to go off screen.

  Usually, no horizontal scrolling is in effect; then the leftmost
column is at the left edge of the window.  In this state, scrolling to
the right is meaningless, since there is no data to the left of the edge
to be revealed by it; so this is not allowed.  Scrolling to the left is
allowed; it scrolls the first columns of text off the edge of the window
and can reveal additional columns on the right that were truncated
before.  Once a window has a nonzero amount of leftward horizontal
scrolling, you can scroll it back to the right, but only so far as to
reduce the net horizontal scroll to zero.  There is no limit to how far
left you can scroll, but eventually all the text will disappear off the
left edge.

@vindex auto-hscroll-mode
  If @code{auto-hscroll-mode} is set, redisplay automatically alters
the horizontal scrolling of a window as necessary to ensure that point
is always visible.  However, you can still set the horizontal
scrolling value explicitly.  The value you specify serves as a lower
bound for automatic scrolling, i.e. automatic scrolling will not
scroll a window to a column less than the specified one.

@deffn Command scroll-left &optional count set-minimum
This function scrolls the selected window @var{count} columns to the
left (or to the right if @var{count} is negative).  The default
for @var{count} is the window width, minus 2.

The return value is the total amount of leftward horizontal scrolling in
effect after the change---just like the value returned by
@code{window-hscroll} (below).

Once you scroll a window as far right as it can go, back to its normal
position where the total leftward scrolling is zero, attempts to scroll
any farther right have no effect.

If @var{set-minimum} is non-@code{nil}, the new scroll amount becomes
the lower bound for automatic scrolling; that is, automatic scrolling
will not scroll a window to a column less than the value returned by
this function.  Interactive calls pass non-@code{nil} for
@var{set-minimum}.
@end deffn

@deffn Command scroll-right &optional count set-minimum
This function scrolls the selected window @var{count} columns to the
right (or to the left if @var{count} is negative).  The default
for @var{count} is the window width, minus 2.  Aside from the direction
of scrolling, this works just like @code{scroll-left}.
@end deffn

@defun window-hscroll &optional window
This function returns the total leftward horizontal scrolling of
@var{window}---the number of columns by which the text in @var{window}
is scrolled left past the left margin.  The default for
@var{window} is the selected window.

The return value is never negative.  It is zero when no horizontal
scrolling has been done in @var{window} (which is usually the case).


@example
@group
(window-hscroll)
     @result{} 0
@end group
@group
(scroll-left 5)
     @result{} 5
@end group
@group
(window-hscroll)
     @result{} 5
@end group
@end example
@end defun

@defun set-window-hscroll window columns
This function sets horizontal scrolling of @var{window}.  The value of
@var{columns} specifies the amount of scrolling, in terms of columns
from the left margin.  The argument @var{columns} should be zero or
positive; if not, it is taken as zero.  Fractional values of
@var{columns} are not supported at present.

Note that @code{set-window-hscroll} may appear not to work if you test
it by evaluating a call with @kbd{M-:} in a simple way.  What happens
is that the function sets the horizontal scroll value and returns, but
then redisplay adjusts the horizontal scrolling to make point visible,
and this overrides what the function did.  You can observe the
function's effect if you call it while point is sufficiently far from
the left margin that it will remain visible.

The value returned is @var{columns}.

@example
@group
(set-window-hscroll (selected-window) 10)
     @result{} 10
@end group
@end example
@end defun

   Here is how you can determine whether a given position @var{position}
is off the screen due to horizontal scrolling:

@example
@group
(defun hscroll-on-screen (window position)
  (save-excursion
    (goto-char position)
    (and
     (>= (- (current-column) (window-hscroll window)) 0)
     (< (- (current-column) (window-hscroll window))
        (window-width window)))))
@end group
@end example


@node Coordinates and Windows
@section Coordinates and Windows

This section describes how to relate screen coordinates to windows.

@defun window-at x y &optional frame
This function returns the window containing the specified cursor
position in the frame @var{frame}.  The coordinates @var{x} and @var{y}
are measured in characters and count from the top left corner of the
frame.  If they are out of range, @code{window-at} returns @code{nil}.

If you omit @var{frame}, the selected frame is used.
@end defun

@defun coordinates-in-window-p coordinates window
This function checks whether a particular frame position falls within
the window @var{window}.

The argument @var{coordinates} is a cons cell of the form @code{(@var{x}
. @var{y})}.  The coordinates @var{x} and @var{y} are measured in
characters, and count from the top left corner of the screen or frame.

The value returned by @code{coordinates-in-window-p} is non-@code{nil}
if the coordinates are inside @var{window}.  The value also indicates
what part of the window the position is in, as follows:

@table @code
@item (@var{relx} . @var{rely})
The coordinates are inside @var{window}.  The numbers @var{relx} and
@var{rely} are the equivalent window-relative coordinates for the
specified position, counting from 0 at the top left corner of the
window.

@item mode-line
The coordinates are in the mode line of @var{window}.

@item header-line
The coordinates are in the header line of @var{window}.

@item vertical-line
The coordinates are in the vertical line between @var{window} and its
neighbor to the right.  This value occurs only if the window doesn't
have a scroll bar; positions in a scroll bar are considered outside the
window for these purposes.

@item left-fringe
@itemx right-fringe
The coordinates are in the left or right fringe of the window.

@item left-margin
@itemx right-margin
The coordinates are in the left or right margin of the window.

@item nil
The coordinates are not in any part of @var{window}.
@end table

The function @code{coordinates-in-window-p} does not require a frame as
argument because it always uses the frame that @var{window} is on.
@end defun


@node Window Configurations
@section Window Configurations
@cindex window configurations
@cindex saving window information

A @dfn{window configuration} records the entire layout of one
frame---all windows, their sizes, which buffers they contain, how those
buffers are scrolled, and their values of point and the mark; also their
fringes, margins, and scroll bar settings.  It also includes the value
of @code{minibuffer-scroll-window}.  As a special exception, the window
configuration does not record the value of point in the selected window
for the current buffer.

  You can bring back an entire frame layout by restoring a previously
saved window configuration.  If you want to record the layout of all
frames instead of just one, use a frame configuration instead of a
window configuration; see @ref{Frame Configurations}.

@defun current-window-configuration &optional frame
This function returns a new object representing @var{frame}'s current
window configuration.  The default for @var{frame} is the selected
frame.
@end defun

@defun set-window-configuration configuration
This function restores the configuration of windows and buffers as
specified by @var{configuration}, for the frame that @var{configuration}
was created for.

The argument @var{configuration} must be a value that was previously
returned by @code{current-window-configuration}.  The configuration is
restored in the frame from which @var{configuration} was made, whether
that frame is selected or not.  This always counts as a window size
change and triggers execution of the @code{window-size-change-functions}
(@pxref{Window Hooks}), because @code{set-window-configuration} doesn't
know how to tell whether the new configuration actually differs from the
old one.

If the frame which @var{configuration} was saved from is dead, all this
function does is restore the three variables @code{window-min-height},
@code{window-min-width} and @code{minibuffer-scroll-window}. In this
case, the function returns @code{nil}.  Otherwise, it returns @code{t}.

Here is a way of using this function to get the same effect
as @code{save-window-excursion}:

@example
@group
(let ((config (current-window-configuration)))
  (unwind-protect
      (progn (split-window-vertically nil)
             @dots{})
    (set-window-configuration config)))
@end group
@end example
@end defun

@defspec save-window-excursion forms@dots{}
This special form records the window configuration, executes @var{forms}
in sequence, then restores the earlier window configuration.  The window
configuration includes, for each window, the value of point and the
portion of the buffer that is visible.  It also includes the choice of
selected window.  However, it does not include the value of point in
the current buffer; use @code{save-excursion} also, if you wish to
preserve that.

Don't use this construct when @code{save-selected-window} is sufficient.

Exit from @code{save-window-excursion} always triggers execution of
@code{window-size-change-functions}.  (It doesn't know how to tell
whether the restored configuration actually differs from the one in
effect at the end of the @var{forms}.)

The return value is the value of the final form in @var{forms}.
For example:

@example
@group
(split-window)
     @result{} #<window 25 on control.texi>
@end group
@group
(setq w (selected-window))
     @result{} #<window 19 on control.texi>
@end group
@group
(save-window-excursion
  (delete-other-windows w)
  (switch-to-buffer "foo")
  'do-something)
     @result{} do-something
     ;; @r{The screen is now split again.}
@end group
@end example
@end defspec

@defun window-configuration-p object
This function returns @code{t} if @var{object} is a window configuration.
@end defun

@defun compare-window-configurations config1 config2
This function compares two window configurations as regards the
structure of windows, but ignores the values of point and mark and the
saved scrolling positions---it can return @code{t} even if those
aspects differ.

The function @code{equal} can also compare two window configurations; it
regards configurations as unequal if they differ in any respect, even a
saved point or mark.
@end defun

@defun window-configuration-frame config
This function returns the frame for which the window configuration
@var{config} was made.
@end defun

  Other primitives to look inside of window configurations would make
sense, but are not implemented because we did not need them.  See the
file @file{winner.el} for some more operations on windows
configurations.

  The objects returned by @code{current-window-configuration} die
together with the Emacs process.  In order to store a window
configuration on disk and read it back in another Emacs session the
following two functions can be used.

@defun window-state-get &optional window markers
This function returns the state of @var{window} as a Lisp object.  The
argument @var{window} can be any window and defaults to the root window
of the selected frame.

The optional argument @var{markers} non-@code{nil} means to use markers
for sampling positions like @code{window-point} or @code{window-start}.
This argument should be non-@code{nil} only if the value is used for
putting the state back in the same session since markers slow down
processing.
@end defun

The value returned by @code{window-state-get} can be converted by using
one of the functions defined by Desktop Save Mode (@pxref{Desktop Save
Mode}) to an object that can be written to a file.  Such objects can be
read back and converted to a Lisp object representing the state of the
window.  That Lisp object can be used as argument for the following
function in order to restore the state window in another window.

@defun window-state-put state &optional window ignore
This function puts the window state @var{state} into @var{window}.  The
argument @var{state} should be the state of a window returned by an
earlier invocation of @code{window-state-get}, see above.  The optional
argument @var{window} must specify a live window and defaults to the
selected one.

The optional argument @var{ignore} non-@code{nil} means to ignore
minimum window sizes and fixed size restrictions.  If @var{ignore}
equals @code{safe}, this means subwindows can get as small as one line
and/or two columns.
@end defun


@node Window Parameters
@section Window Parameters
@cindex window parameters

This section describes how window parameters can be used to associate
additional information with windows.

@defun window-parameter window parameter
This function returns @var{window}'s value for @var{parameter}.  The
default for @var{window} is the selected window.  If @var{window} has no
setting for @var{parameter}, this function returns @code{nil}.
@end defun

@defun window-parameters &optional window
This function returns all parameters of @var{window} and their values.
The default for @var{window} is the selected window.  The return value,
if non-@code{nil} is an association list whose elements have the form
@code{(@var{parameter} . @var{value})}.
@end defun

@defun set-window-parameter window parameter value
This function sets @var{window}'s value of @var{parameter} to
@var{value} and returns @var{value}.  The default for @var{window}
is the selected window.
@end defun

Some functions, notably @code{delete-window},
@code{delete-other-windows} and @code{split-window} may behave specially
when their @var{window} argument has a parameter set.  You can override
such special behavior by binding the following variable to a
non-@code{nil} value:

@defvar ignore-window-parameters
If this variable is non-@code{nil}, some standard functions do not
process window parameters.  The functions currently affected by this are
@code{split-window}, @code{delete-window}, @code{delete-other-windows}
and @code{other-window}.

An application can bind this variable to a non-@code{nil} value around
calls to these functions.  If it does so, the application is fully
responsible for correctly assigning the parameters of all involved
windows when exiting that function.
@end defvar

The following parameters are currently used by the window management
code.

@table @asis
@item @code{delete-window}
This parameter affects the execution of @code{delete-window}
(@pxref{Deleting Windows}).

@item @code{delete-other-windows}
This parameter affects the execution of @code{delete-other-windows}
(@pxref{Deleting Windows}).

@item @code{split-window}
This parameter affects the execution of @code{split-window}
(@pxref{Splitting Windows}).

@item @code{other-window}
This parameter affects the execution of @code{other-window}
(@pxref{Cyclic Window Ordering}).

@item @code{no-other-window}
This parameter marks the window as not selectable by @code{other-window}
(@pxref{Cyclic Window Ordering}).
@end table

In addition, the parameters @code{window-atom} and @code{window-side}
are reserved and should not be used by applications.  The
@code{quit-restore} parameter tells how to proceed with a window when
the buffer it shows is no more needed.  This parameter is installed by
the buffer display functions (@pxref{Choosing Window}) and consulted by
the function @code{quit-window} (@pxref{Quitting Windows}).


@node Window Hooks
@section Hooks for Window Scrolling and Changes
@cindex hooks for window operations

This section describes how a Lisp program can take action whenever a
window displays a different part of its buffer or a different buffer.
There are three actions that can change this: scrolling the window,
switching buffers in the window, and changing the size of the window.
The first two actions run @code{window-scroll-functions}; the last runs
@code{window-size-change-functions}.

@defvar window-scroll-functions
This variable holds a list of functions that Emacs should call before
redisplaying a window with scrolling.  Displaying a different buffer in
the window also runs these functions.

This variable is not a normal hook, because each function is called with
two arguments: the window, and its new display-start position.

These functions must be careful in using @code{window-end}
(@pxref{Window Start and End}); if you need an up-to-date value, you
must use the @var{update} argument to ensure you get it.

@strong{Warning:} don't use this feature to alter the way the window
is scrolled.  It's not designed for that, and such use probably won't
work.
@end defvar

@defvar window-size-change-functions
This variable holds a list of functions to be called if the size of any
window changes for any reason.  The functions are called just once per
redisplay, and just once for each frame on which size changes have
occurred.

Each function receives the frame as its sole argument.  There is no
direct way to find out which windows on that frame have changed size, or
precisely how.  However, if a size-change function records, at each
call, the existing windows and their sizes, it can also compare the
present sizes and the previous sizes.

Creating or deleting windows counts as a size change, and therefore
causes these functions to be called.  Changing the frame size also
counts, because it changes the sizes of the existing windows.

It is not a good idea to use @code{save-window-excursion} (@pxref{Window
Configurations}) in these functions, because that always counts as a
size change, and it would cause these functions to be called over and
over.  In most cases, @code{save-selected-window} (@pxref{Selecting
Windows}) is what you need here.
@end defvar

@defvar window-configuration-change-hook
A normal hook that is run every time you change the window configuration
of an existing frame.  This includes splitting or deleting windows,
changing the sizes of windows, or displaying a different buffer in a
window.

The buffer-local part of this hook is run once per each window on the
affected frame, with the relevant window selected and its buffer
current.  The global part is run once for the modified frame, with that
frame selected.
@end defvar

  In addition, you can use @code{jit-lock-register} to register a Font
Lock fontification function, which will be called whenever parts of a
buffer are (re)fontified because a window was scrolled or its size
changed.  @xref{Other Font Lock Variables}.
